//===========================================================	//===========================================================
// Athena++ astrophysical MHD code				// Athena++ astrophysical MHD code
// Copyright(C) 2014 James M. Stone <jmstone@princeton.edu> a	// Copyright(C) 2014 James M. Stone <jmstone@princeton.edu> a
// Licensed under the 3-clause BSD License, see LICENSE file 	// Licensed under the 3-clause BSD License, see LICENSE file 
//===========================================================	//===========================================================
//! \file accretion.cpp						//! \file accretion.cpp
//  \brief Problem generator for steady-state accretion, deve	//  \brief Problem generator for steady-state accretion, deve
//								//

#define COMP_DT 1    // Compute hydro time-steps and save to 	#define COMP_DT 1    // Compute hydro time-steps and save to 

// C/C++ headers						// C/C++ headers
#include <algorithm>  // min, max				#include <algorithm>  // min, max
#include <cmath>						#include <cmath>
#include <cstdlib>						#include <cstdlib>
#include <fstream>						#include <fstream>
#include <iostream>						#include <iostream>
#include <limits>   // std::numeric_limits<float>::epsilon()	#include <limits>   // std::numeric_limits<float>::epsilon()
#include <sstream>						#include <sstream>
#include <string>						#include <string>
// Athena++ headers						// Athena++ headers
#include "../athena.hpp"					#include "../athena.hpp"
#include "../athena_arrays.hpp"					#include "../athena_arrays.hpp"
#include "../coordinates/coordinates.hpp"			#include "../coordinates/coordinates.hpp"
#include "../eos/eos.hpp"					#include "../eos/eos.hpp"
#include "../field/field.hpp"					#include "../field/field.hpp"
#include "../globals.hpp"					#include "../globals.hpp"
#include "../hydro/hydro.hpp"					#include "../hydro/hydro.hpp"
#include "../mesh/mesh.hpp"					#include "../mesh/mesh.hpp"
#include "../parameter_input.hpp"				#include "../parameter_input.hpp"
#include "../utils/utils.hpp"					#include "../utils/utils.hpp"
#include "../scalars/scalars.hpp"				#include "../scalars/scalars.hpp"

// Static Variables						// Static Variables
// r=r_PNS equilibrium quantities: inner pressure, inner temp	// r=r_PNS equilibrium quantities: inner pressure, inner temp
static Real T_eq, Ye_eq, dpdd_0, pModify, Mach;			static Real T_eq, Ye_eq, dpdd_0, pModify, Mach;
// Problem quantities: gravitational mass, inner density, out	// Problem quantities: gravitational mass, inner density, out
// inverse inner radius squared (qdotQW), Avogadro's number, 	// inverse inner radius squared (qdotQW), Avogadro's number, 
static Real mu, rho_0, rho_f, v_f, p_f, r_0, inv_r2, Na, Tc, 	static Real mu, rho_0, rho_f, v_f, p_f, r_0, inv_r2, Na, Tc, 
// EoS quantities: initial Lnu*Enu^2 (qdotQW), initial Lnubar	// EoS quantities: initial Lnu*Enu^2 (qdotQW), initial Lnubar
// perturbation time coefficient, Coeff_nu perturbation param	// perturbation time coefficient, Coeff_nu perturbation param
// electrion neutrino average energy, electron antineutrino a	// electrion neutrino average energy, electron antineutrino a
// floor temperature.						// floor temperature.
static Real Coeff_nu_0, Coeff_nubar_0, t_L_0, t_L_1, t_coeff,	static Real Coeff_nu_0, Coeff_nubar_0, t_L_0, t_L_1, t_coeff,
// Machine epsilon.						// Machine epsilon.
static const Real float_eps = std::numeric_limits<Real>::epsi	static const Real float_eps = std::numeric_limits<Real>::epsi
// Number of rows in the IC file				// Number of rows in the IC file
static int rows;						static int rows;
// User-ouput variable (UOV) indices				// User-ouput variable (UOV) indices
static int IDT1, IDT2, IDT3, IDT4, IDT5, IDT6, IDT7, IDT8, ID	static int IDT1, IDT2, IDT3, IDT4, IDT5, IDT6, IDT7, IDT8, ID
// IC file logical parameter					// IC file logical parameter
static bool use_IC_file;					static bool use_IC_file;
// Scalar Ye parameters: Ye index in r & s arrays, Ye index i	// Scalar Ye parameters: Ye index in r & s arrays, Ye index i
static int ye_index, t_index, nscalar_size;			static int ye_index, t_index, nscalar_size;
// Scalar Ye parameters: inner boundary ye, outer boundary ye	// Scalar Ye parameters: inner boundary ye, outer boundary ye
static Real ye_0, ye_f;						static Real ye_0, ye_f;
// Scalar Ye pointers: electron number density, electron frac	// Scalar Ye pointers: electron number density, electron frac
Real* edens;							Real* edens;
Real* efrac;							Real* efrac;
// NR parameters: guess temperature, guess electron fraction,	// NR parameters: guess temperature, guess electron fraction,
// tolerance, modifier, maximum iterations, derivative tolera	// tolerance, modifier, maximum iterations, derivative tolera
static Real tg, tgs, yg, dtg, dyg, tolsNR, toldNR, modsNR, mo	static Real tg, tgs, yg, dtg, dyg, tolsNR, toldNR, modsNR, mo
// cross section, tolerance for finding tau, tolerance for ad	// cross section, tolerance for finding tau, tolerance for ad
static Real g_a, delta_np, mcsq, sigma_0, tau_v, tau_epsilon,	static Real g_a, delta_np, mcsq, sigma_0, tau_v, tau_epsilon,
// The number of cycles that must pass before base density is	// The number of cycles that must pass before base density is
static int nthcycle;						static int nthcycle;
// Optical depth						// Optical depth
Real global_tau;						Real global_tau;
// Final active zone velocity					// Final active zone velocity
Real Vr_FinalActiveZone;					Real Vr_FinalActiveZone;
// Final Ghozt zone pressure					// Final Ghozt zone pressure
Real P_GZ;							Real P_GZ;

// Vector Potential						// Vector Potential
static Real A3(const Real x1, const Real x2, const Real x3) {	static Real A3(const Real x1, const Real x2, const Real x3) {
  Real a3 = 0.5 * B_0 * r_0 * std::pow(r_0/x1,2) *		  Real a3 = 0.5 * B_0 * r_0 * std::pow(r_0/x1,2) *
    (std::sin(x2)*std::cos(alpha) - std::cos(x2)*std::cos(x3)	    (std::sin(x2)*std::cos(alpha) - std::cos(x2)*std::cos(x3)
  return a3;							  return a3;
}								}

static Real A2(const Real x1, const Real x2, const Real x3) {	static Real A2(const Real x1, const Real x2, const Real x3) {
  Real a2 = -0.5 * B_0 * r_0 * std::pow(r_0/x1,2) * std::sin(	  Real a2 = -0.5 * B_0 * r_0 * std::pow(r_0/x1,2) * std::sin(
  return a2;							  return a2;
}								}

static Real A1(const Real x1, const Real x2, const Real x3) {	static Real A1(const Real x1, const Real x2, const Real x3) {
  Real a1=0.0;							  Real a1=0.0;
  return a1;							  return a1;
}								}

// Estimates Fermi integrals up to n=5 for a given eta parame	// Estimates Fermi integrals up to n=5 for a given eta parame
Real fermi(Real n, Real eta){					Real fermi(Real n, Real eta){
  if (n==0) {							  if (n==0) {
    Real fermi = log(1.0 + exp(eta));				    Real fermi = log(1.0 + exp(eta));
    return fermi;						    return fermi;
  } else if (n==1) {						  } else if (n==1) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,2) / 2.0 + 1.6449341;		    Real s  = std::pow(eta,2) / 2.0 + 1.6449341;
    Real ff = a - std::pow(a,2) / 4.0 + std::pow(a,3) / 9.0 -	    Real ff = a - std::pow(a,2) / 4.0 + std::pow(a,3) / 9.0 -
    if (eta < 0) {						    if (eta < 0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if (eta == 0) {					    } else if (eta == 0) {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    }								    }
  } else if (n==2) {						  } else if (n==2) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,3) / 3.0 + 3.2898681 * eta;		    Real s  = std::pow(eta,3) / 3.0 + 3.2898681 * eta;
    Real ff = 2.0 * (a - std::pow(a,2) / 8.0 + std::pow(a,3) 	    Real ff = 2.0 * (a - std::pow(a,2) / 8.0 + std::pow(a,3) 
    if (eta<0) {						    if (eta<0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if (eta==0) {					    } else if (eta==0) {
        Real fermi = s + ff;					        Real fermi = s + ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s + ff;					        Real fermi = s + ff;
        return fermi;						        return fermi;
    }								    }
  } else if (n==3) {						  } else if (n==3) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,4) / 4.0 + 4.9348022 * std::pow(et	    Real s  = std::pow(eta,4) / 4.0 + 4.9348022 * std::pow(et
    Real ff = 6.0 * (a - std::pow(a,2) / 16.0 + std::pow(a,3)	    Real ff = 6.0 * (a - std::pow(a,2) / 16.0 + std::pow(a,3)
    if (eta<0) {						    if (eta<0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if (eta==0) {					    } else if (eta==0) {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    }								    }
  } else if (n==4) {						  } else if (n==4) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,5) / 5.0 + 6.5797363 * std::pow(et	    Real s  = std::pow(eta,5) / 5.0 + 6.5797363 * std::pow(et
    Real ff = 24.0 * (a - std::pow(a,2) / 32.0 + std::pow(a,3	    Real ff = 24.0 * (a - std::pow(a,2) / 32.0 + std::pow(a,3
    if (eta<0) {						    if (eta<0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if (eta==0) {					    } else if (eta==0) {
        Real fermi = s + ff;					        Real fermi = s + ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s + ff;					        Real fermi = s + ff;
        return fermi;						        return fermi;
    }								    }
  } else if (n==5) {						  } else if (n==5) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,6) / 6.0 + 8.2246703 * std::pow(et	    Real s  = std::pow(eta,6) / 6.0 + 8.2246703 * std::pow(et
    Real ff = 120.0 * (a - std::pow(a,2) / 64.0 + std::pow(a,	    Real ff = 120.0 * (a - std::pow(a,2) / 64.0 + std::pow(a,
    if(eta<0) {							    if(eta<0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if(eta==0) {						    } else if(eta==0) {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    }								    }
  } else {							  } else {
      std::cout << " (accretion.cpp) \n n for fermi_approx wa	      std::cout << " (accretion.cpp) \n n for fermi_approx wa
      return 0.0;						      return 0.0;
  }								  }
}								}

// Finds the QW EoS electron chemical potential.		// Finds the QW EoS electron chemical potential.
Real QWEta(Real rho, Real T, Real Ye) {				Real QWEta(Real rho, Real T, Real Ye) {
  // Returns eta = mu_e / kbT					  // Returns eta = mu_e / kbT
  // Physical constants						  // Physical constants
  Real third         = 1.0 / 3.0;				  Real third         = 1.0 / 3.0;
  Real c             = 2.99792458e10;              // Speed o	  Real c             = 2.99792458e10;              // Speed o
  Real k             = 1.380649e-16;               // Boltzma	  Real k             = 1.380649e-16;               // Boltzma
  Real mn            = 1.6726e-24;                 // Baryon 	  Real mn            = 1.6726e-24;                 // Baryon 
  Real hbar          = 6.62607015e-27/(2.0*PI);    // Reduced	  Real hbar          = 6.62607015e-27/(2.0*PI);    // Reduced
  Real c3            = std::pow(k/(hbar*c),3);			  Real c3            = std::pow(k/(hbar*c),3);
  Real eta_den_const = std::pow(6.0,2.0*third);			  Real eta_den_const = std::pow(6.0,2.0*third);
  Real root3         = std::sqrt(3.0);				  Real root3         = std::sqrt(3.0);
  Real eta_den_A     = std::pow(2.0,third) / eta_den_const;	  Real eta_den_A     = std::pow(2.0,third) / eta_den_const;
  Real eta_den_B     = 2.0*std::pow(3.0,third)/eta_den_const;	  Real eta_den_B     = 2.0*std::pow(3.0,third)/eta_den_const;

  Real vol       = mn/rho;					  Real vol       = mn/rho;
  Real T3        = T*T*T;					  Real T3        = T*T*T;
  Real T4        = T*T3;					  Real T4        = T*T3;
  Real a         = c3*std::pow(T,3)*vol*(PI/3.0);		  Real a         = c3*std::pow(T,3)*vol*(PI/3.0);
  Real a2        = SQR(a);					  Real a2        = SQR(a);
  Real a4        = SQR(a2);					  Real a4        = SQR(a2);
  Real a6        = a2 * a4;					  Real a6        = a2 * a4;
  Real y2        = SQR(Ye);					  Real y2        = SQR(Ye);
  Real b         = std::sqrt(4.0*a6+27.0*a4*y2);		  Real b         = std::sqrt(4.0*a6+27.0*a4*y2);
  Real term      = std::pow(9.0*a2*Ye+root3*b, third);		  Real term      = std::pow(9.0*a2*Ye+root3*b, third);
  Real eta_by_pi = (eta_den_A)*term/a - (eta_den_B)*a/term; /	  Real eta_by_pi = (eta_den_A)*term/a - (eta_den_B)*a/term; /
  Real eta       = eta_by_pi * PI;				  Real eta       = eta_by_pi * PI;
  return eta;							  return eta;
}								}

// Qian & Woosley (1996) Heating/cooling function		// Qian & Woosley (1996) Heating/cooling function
Real qdotQW(Real temp, Real x, Real ye, Real time) {		Real qdotQW(Real temp, Real x, Real ye, Real time) {
  // temp is in MeV						  // temp is in MeV
  // returns heating - cooling in units of MeV s^{-1} g^{-1} 	  // returns heating - cooling in units of MeV s^{-1} g^{-1} 
  // smoothly transition from 0 at t<=t_L_0 to 1 at t>=t_L_1	  // smoothly transition from 0 at t<=t_L_0 to 1 at t>=t_L_1
  Real f           = (time <= t_L_0) ? 0.0 :			  Real f           = (time <= t_L_0) ? 0.0 :
                    ((time >= t_L_1) ? 1.0 : SQR(std::sin((ti	                    ((time >= t_L_1) ? 1.0 : SQR(std::sin((ti
  Real Coeff_nu    = Coeff_nu_0 + f * dCoeff_nu;		  Real Coeff_nu    = Coeff_nu_0 + f * dCoeff_nu;
  Real Coeff_nubar = Coeff_nubar_0 + f * dCoeff_nubar;		  Real Coeff_nubar = Coeff_nubar_0 + f * dCoeff_nubar;
  // Heating; multiplied 1e12 becasue r is units of 1e6 cm (s	  // Heating; multiplied 1e12 becasue r is units of 1e6 cm (s
  Real out = 1e12*9.65*Na*((1.0-ye)*Coeff_nu + ye*Coeff_nubar	  Real out = 1e12*9.65*Na*((1.0-ye)*Coeff_nu + ye*Coeff_nubar
  out     -= 2.27*Na*std::pow(temp,6); // cooling		  out     -= 2.27*Na*std::pow(temp,6); // cooling
  if(temp<Tc) {							  if(temp<Tc) {
    out *= std::exp(-0.5/temp); //alpha particles turnoff hea	    out *= std::exp(-0.5/temp); //alpha particles turnoff hea
  }								  }
//  if(temp>Th){						//  if(temp>Th){
//    out *= std::exp(-tau);					//    out *= std::exp(-tau);
//  }								//  }
  return out;							  return out;
}								}

Real YeTejas(Real temp, Real ye, Real x, Real Rho) {		Real YeTejas(Real temp, Real ye, Real x, Real Rho) {
  // Returns Sources for Yedot=vdYe/dr in s^-1 units		  // Returns Sources for Yedot=vdYe/dr in s^-1 units
  // Temperature argument is in MeV				  // Temperature argument is in MeV
  // Define constants						  // Define constants
  Real alpha    = 1.26;                                // Cou	  Real alpha    = 1.26;                                // Cou
  Real G_F      = 1.16637e-11;                         // Fer	  Real G_F      = 1.16637e-11;                         // Fer
  Real Delta    = 1.2935;                              // neu	  Real Delta    = 1.2935;                              // neu
  Real hbar     = 6.582119569e-22;                     // Pla	  Real hbar     = 6.582119569e-22;                     // Pla
  Real c        = 2.99792458e10;                       // Lig	  Real c        = 2.99792458e10;                       // Lig
  Real erg2MeV  = 6.24151e5;                           // con	  Real erg2MeV  = 6.24151e5;                           // con
  //Luminosity and epsilon					  //Luminosity and epsilon
  Real lnu_y      = L_nue;					  Real lnu_y      = L_nue;
  Real epsnu_y    = eps_nue;					  Real epsnu_y    = eps_nue;
  Real lnubar_y   = L_nueb;					  Real lnubar_y   = L_nueb;
  Real epsnubar_y = eps_nueb;					  Real epsnubar_y = eps_nueb;
//  if (time<t_L_0) {						//  if (time<t_L_0) {
//      lnu_y=L_nu;						//      lnu_y=L_nu;
//      lnubar_y=L_nubar;					//      lnubar_y=L_nubar;
//      epsnu_y=eps_nu;						//      epsnu_y=eps_nu;
//      epsnubar_y=eps_nubar;					//      epsnubar_y=eps_nubar;
//  }								//  }
//  if (time>=t_L_0 && time<=t_L_1) {				//  if (time>=t_L_0 && time<=t_L_1) {
//      //Coeff_nu = Coeff_nu_0*std::pow(t_L_0/time,0.9240006	//      //Coeff_nu = Coeff_nu_0*std::pow(t_L_0/time,0.9240006
//      //Coeff_nubar = Coeff_nubar_0*std::pow(t_L_0/time,0.9	//      //Coeff_nubar = Coeff_nubar_0*std::pow(t_L_0/time,0.9
//      if(time<=3.417921) {					//      if(time<=3.417921) {
//        lnu_y = L_nu*std::pow((t_L_0-0.399081)/(time-0.3990	//        lnu_y = L_nu*std::pow((t_L_0-0.399081)/(time-0.3990
//        lnubar_y = L_nubar*std::pow((t_L_0-0.399081)/(time-	//        lnubar_y = L_nubar*std::pow((t_L_0-0.399081)/(time-
//        epsnubar_y=eps_nubar;					//        epsnubar_y=eps_nubar;
//        epsnu_y=eps_nu;					//        epsnu_y=eps_nu;
//        //Coeff_nu = Coeff_nu_0*std::pow((t_L_0-0.399991)/(	//        //Coeff_nu = Coeff_nu_0*std::pow((t_L_0-0.399991)/(
//        //Coeff_nubar = Coeff_nubar_0*std::pow((t_L_0-0.399	//        //Coeff_nubar = Coeff_nubar_0*std::pow((t_L_0-0.399
//        //Coeff_nu = Coeff_nu_0*std::pow((t_L_0-0.399235)/(	//        //Coeff_nu = Coeff_nu_0*std::pow((t_L_0-0.399235)/(
//        //Coeff_nubar = Coeff_nubar_0*std::pow((t_L_0-0.399	//        //Coeff_nubar = Coeff_nubar_0*std::pow((t_L_0-0.399
//      }							//      }
//      else {							//      else {
//        lnu_y = L_nu*std::pow((3.01884)/(time-0.399081),1.2	//        lnu_y = L_nu*std::pow((3.01884)/(time-0.399081),1.2
//        lnubar_y = L_nubar*std::pow((3.01884)/(time-0.39908	//        lnubar_y = L_nubar*std::pow((3.01884)/(time-0.39908
//        epsnu_y = eps_nu*std::pow((3.01884)/(time-0.399081)	//        epsnu_y = eps_nu*std::pow((3.01884)/(time-0.399081)
//        epsnubar_y = eps_nubar*std::pow((3.01884)/(time-0.3	//        epsnubar_y = eps_nubar*std::pow((3.01884)/(time-0.3
//      }							//      }
//  }								//  }
//  if (time>t_L_1) {						//  if (time>t_L_1) {
//      lnu_y=L_nu_f;						//      lnu_y=L_nu_f;
//      lnubar_y=L_nubar_f;					//      lnubar_y=L_nubar_f;
//      epsnu_y=eps_nu_f;					//      epsnu_y=eps_nu_f;
//      epsnubar_y=eps_nubar_f;					//      epsnubar_y=eps_nubar_f;
//  }								//  }

  Real ferm5 = fermi(5,0); //118.266;				  Real ferm5 = fermi(5,0); //118.266;
  Real ferm4 = fermi(4,0); //23.3309;				  Real ferm4 = fermi(4,0); //23.3309;
  Real ferm3 = fermi(3,0); //5.6822;				  Real ferm3 = fermi(3,0); //5.6822;
  Real ferm2 = fermi(2,0); //1.80309;				  Real ferm2 = fermi(2,0); //1.80309;

  Real ktemp_nubar = epsnubar_y  * ferm2 / ferm3;		  Real ktemp_nubar = epsnubar_y  * ferm2 / ferm3;
  Real eavg1_nubar = ktemp_nubar * ferm3 / ferm2;		  Real eavg1_nubar = ktemp_nubar * ferm3 / ferm2;
  Real eavg2_nubar = ktemp_nubar * ktemp_nubar * ferm4 / ferm	  Real eavg2_nubar = ktemp_nubar * ktemp_nubar * ferm4 / ferm

  Real ktemp_nu = epsnu_y  * ferm2 / ferm3;			  Real ktemp_nu = epsnu_y  * ferm2 / ferm3;
  Real eavg1_nu = ktemp_nu * ferm3 / ferm2;			  Real eavg1_nu = ktemp_nu * ferm3 / ferm2;
  Real eavg2_nu = ktemp_nu * ktemp_nu * ferm4 / ferm2;		  Real eavg2_nu = ktemp_nu * ktemp_nu * ferm4 / ferm2;

  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al	  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al
                      *(eavg2_nu/eavg1_nu+2.0*Delta+Delta*Del	                      *(eavg2_nu/eavg1_nu+2.0*Delta+Delta*Del
  Real lambda_nuebar_p  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha	  Real lambda_nuebar_p  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha
                      *(eavg2_nubar/eavg1_nubar-2.0*Delta+Del	                      *(eavg2_nubar/eavg1_nubar-2.0*Delta+Del

// Calculate Eta, send in T in K				// Calculate Eta, send in T in K
  Real Eta = QWEta(Rho,temp/8.6173e-11,ye);			  Real Eta = QWEta(Rho,temp/8.6173e-11,ye);

  // Reverse reaction rates					  // Reverse reaction rates
  Real f4_0         = fermi(4,0.0);				  Real f4_0         = fermi(4,0.0);
  Real f4_eta       = fermi(4,Eta);				  Real f4_eta       = fermi(4,Eta);
  Real f4_negeta    = fermi(4,-1.0*Eta);			  Real f4_negeta    = fermi(4,-1.0*Eta);
  Real lambda_ele_p = 0.448*std::pow(temp,5.0)*f4_eta/f4_0;  	  Real lambda_ele_p = 0.448*std::pow(temp,5.0)*f4_eta/f4_0;  
  Real lambda_pos_n = 0.448*std::pow(temp,5.0)*f4_negeta/f4_0	  Real lambda_pos_n = 0.448*std::pow(temp,5.0)*f4_negeta/f4_0

  // Source term						  // Source term
  //std::cout<<"ENTER YeSOurce   "<<L_nu<<"    "<<eps_nu<<"  	  //std::cout<<"ENTER YeSOurce   "<<L_nu<<"    "<<eps_nu<<"  
  return lambda_nue_n+lambda_pos_n-(lambda_nue_n+lambda_pos_n	  return lambda_nue_n+lambda_pos_n-(lambda_nue_n+lambda_pos_n

}								}


Real YeSource_QW_Modified(Real Rho, Real T, Real Ye, Real x, 	Real YeSource_QW_Modified(Real Rho, Real T, Real Ye, Real x, 
  // T is in MeV						  // T is in MeV
  // Returns source term for Yedot from QW 1996			  // Returns source term for Yedot from QW 1996
  Real kbol_MeV   = 8.61733326e-11;                          	  Real kbol_MeV   = 8.61733326e-11;                          
  Real sigma_0    = 1.76e-44;                                	  Real sigma_0    = 1.76e-44;                                
  Real alpha      = 1.26;                                    	  Real alpha      = 1.26;                                    
  Real G_F        = 1.1663787e-5 * std::pow(1.0e3,-2);       	  Real G_F        = 1.1663787e-5 * std::pow(1.0e3,-2);       
  Real mn         = 1.0 / Na;                                	  Real mn         = 1.0 / Na;                                
  Real E_e        = 0.511;                                   	  Real E_e        = 0.511;                                   
  Real h          = 4.1356677e-21;                           	  Real h          = 4.1356677e-21;                           
  Real hbar       = h / (2.0 * PI);                          	  Real hbar       = h / (2.0 * PI);                          
  Real Delta      = 1.293;                                   	  Real Delta      = 1.293;                                   
  Real c          = 2.99792458e10;                           	  Real c          = 2.99792458e10;                           
  Real kbT_nue    = eps_nue  * fermi(2,0.0) / fermi(3,0.0);  	  Real kbT_nue    = eps_nue  * fermi(2,0.0) / fermi(3,0.0);  
  Real kbT_nueb   = eps_nueb * fermi(2,0.0) / fermi(3,0.0);  	  Real kbT_nueb   = eps_nueb * fermi(2,0.0) / fermi(3,0.0);  
  Real erg2MeV    = 6.24151e5;                               	  Real erg2MeV    = 6.24151e5;                               
  Real prefactor1 = std::pow(hbar * c,2.0) * (1.0 + 3.0 * std	  Real prefactor1 = std::pow(hbar * c,2.0) * (1.0 + 3.0 * std
                   (2.0 * std::pow(PI,2.0) * std::pow(r_0,2.0	                   (2.0 * std::pow(PI,2.0) * std::pow(r_0,2.0
  Real prefactor  = sigma_0 * PI * (1.0 + 3.0 * std::pow(alph	  Real prefactor  = sigma_0 * PI * (1.0 + 3.0 * std::pow(alph
                    (std::pow(E_e,2.0) * std::pow(h * c,3.0))	                    (std::pow(E_e,2.0) * std::pow(h * c,3.0))

  // Calulate eta_e, send T in K				  // Calulate eta_e, send T in K
  Real eta_e = QWEta(Rho,T/kbol_MeV,Ye);			  Real eta_e = QWEta(Rho,T/kbol_MeV,Ye);
  Real F4_e  = fermi(4.0,eta_e);				  Real F4_e  = fermi(4.0,eta_e);

  // Calculate energy moments, let eta_nu = 0			  // Calculate energy moments, let eta_nu = 0
  Real e_nue         = kbT_nue                 * fermi(4.0,0.	  Real e_nue         = kbT_nue                 * fermi(4.0,0.
  Real one_over_Enue = std::pow(kbT_nue,-1.0)  * fermi(2.0,0.	  Real one_over_Enue = std::pow(kbT_nue,-1.0)  * fermi(2.0,0.

  // Lambda terms in s^-1					  // Lambda terms in s^-1
  Real lambda_nue_n  = prefactor1 * (e_nue  + 2.0 * Delta + s	  Real lambda_nue_n  = prefactor1 * (e_nue  + 2.0 * Delta + s
  Real lambda_pos_n  = prefactor * std::pow(T,5.0) * F4_e;	  Real lambda_pos_n  = prefactor * std::pow(T,5.0) * F4_e;

  // Source term from QW 1996 in s^-1				  // Source term from QW 1996 in s^-1
  Real Source = lambda_nue_n + lambda_pos_n;			  Real Source = lambda_nue_n + lambda_pos_n;
//  if(r<30.2e5) {						//  if(r<30.2e5) {
//    std::cout << "--SOURCE------------------------------" <	//    std::cout << "--SOURCE------------------------------" <
//    std::cout << "Source       = " << Source       << " s^-	//    std::cout << "Source       = " << Source       << " s^-
//    std::cout << "x            = " << x            << std::	//    std::cout << "x            = " << x            << std::
//    std::cout << "lambda_nue_n = " << lambda_nue_n << " s^-	//    std::cout << "lambda_nue_n = " << lambda_nue_n << " s^-
//    std::cout << "lambda_pos_n = " << lambda_pos_n << " s^-	//    std::cout << "lambda_pos_n = " << lambda_pos_n << " s^-
//    std::cout << "eta_e        = " << eta_e        << std::	//    std::cout << "eta_e        = " << eta_e        << std::
//    std::cout << "F4_e         = " << F4_e         << std::	//    std::cout << "F4_e         = " << F4_e         << std::
//    std::cout << "T            = " << T            << " MeV	//    std::cout << "T            = " << T            << " MeV
//    std::cout << "Ye           = " << Ye           << std::	//    std::cout << "Ye           = " << Ye           << std::
//    std::cout << "r            = " << r            << " cm"	//    std::cout << "r            = " << r            << " cm"
//    std::cout << "--------------------------------------" <	//    std::cout << "--------------------------------------" <
//  }								//  }
  return Source;						  return Source;
}								}

Real YeSink_QW_Modified(Real Rho, Real T, Real Ye, Real x, Re	Real YeSink_QW_Modified(Real Rho, Real T, Real Ye, Real x, Re
  // T is in MeV						  // T is in MeV
  // Returns sink term for Yedot from QW 1996			  // Returns sink term for Yedot from QW 1996
  Real kbol_MeV   = 8.61733326e-11;                          	  Real kbol_MeV   = 8.61733326e-11;                          
  Real sigma_0    = 1.76e-44;                                	  Real sigma_0    = 1.76e-44;                                
  Real alpha      = 1.26;                                    	  Real alpha      = 1.26;                                    
  Real G_F        = 1.1663787e-5 * std::pow(1.0e3,-2);       	  Real G_F        = 1.1663787e-5 * std::pow(1.0e3,-2);       
  Real mn         = 1.0 / Na;                                	  Real mn         = 1.0 / Na;                                
  Real E_e        = 0.511;                                   	  Real E_e        = 0.511;                                   
  Real h          = 4.1356677e-21;                           	  Real h          = 4.1356677e-21;                           
  Real hbar       = h / (2.0 * PI);                          	  Real hbar       = h / (2.0 * PI);                          
  Real Delta      = 1.293;                                   	  Real Delta      = 1.293;                                   
  Real c          = 2.99792458e10;                           	  Real c          = 2.99792458e10;                           
  Real kbT_nue    = eps_nue  * fermi(2,0.0) / fermi(3,0.0);  	  Real kbT_nue    = eps_nue  * fermi(2,0.0) / fermi(3,0.0);  
  Real kbT_nueb   = eps_nueb * fermi(2,0.0) / fermi(3,0.0);  	  Real kbT_nueb   = eps_nueb * fermi(2,0.0) / fermi(3,0.0);  
  Real erg2MeV    = 6.24151e5;                               	  Real erg2MeV    = 6.24151e5;                               
  Real prefactor1 = std::pow(hbar * c,2.0) * (1.0 + 3.0 * std	  Real prefactor1 = std::pow(hbar * c,2.0) * (1.0 + 3.0 * std
                   (2.0 * std::pow(PI,2.0) * std::pow(r_0,2.0	                   (2.0 * std::pow(PI,2.0) * std::pow(r_0,2.0
  Real prefactor2 = std::pow(hbar * c,2.0) * (1.0 + 3.0 * std	  Real prefactor2 = std::pow(hbar * c,2.0) * (1.0 + 3.0 * std
                   (2.0 * std::pow(PI,2.0) * std::pow(r_0,2.0	                   (2.0 * std::pow(PI,2.0) * std::pow(r_0,2.0
  Real prefactor  = sigma_0 * PI * (1.0 + 3.0 * std::pow(alph	  Real prefactor  = sigma_0 * PI * (1.0 + 3.0 * std::pow(alph
                    (std::pow(E_e,2.0) * std::pow(h * c,3.0))	                    (std::pow(E_e,2.0) * std::pow(h * c,3.0))

  // Calculate eta_e, send T in K				  // Calculate eta_e, send T in K
  Real eta_e = QWEta(Rho,T/kbol_MeV,Ye);			  Real eta_e = QWEta(Rho,T/kbol_MeV,Ye);
  Real F4_e  = fermi(4.0,eta_e);				  Real F4_e  = fermi(4.0,eta_e);
  Real F4_p  = fermi(4.0,-1.0*eta_e);				  Real F4_p  = fermi(4.0,-1.0*eta_e);

  // Calculate energy moments, let eta_nu = 0			  // Calculate energy moments, let eta_nu = 0
  Real e_nue          = kbT_nue                 * fermi(4.0,0	  Real e_nue          = kbT_nue                 * fermi(4.0,0
  Real e_nueb         = kbT_nueb                * fermi(4.0,0	  Real e_nueb         = kbT_nueb                * fermi(4.0,0
  Real one_over_Enue  = std::pow(kbT_nue,-1.0)  * fermi(2.0,0	  Real one_over_Enue  = std::pow(kbT_nue,-1.0)  * fermi(2.0,0
  Real one_over_Enueb = std::pow(kbT_nueb,-1.0) * fermi(2.0,0	  Real one_over_Enueb = std::pow(kbT_nueb,-1.0) * fermi(2.0,0

  // Lambda terms in s^-1					  // Lambda terms in s^-1
  Real lambda_nue_n  = prefactor1 * (e_nue  + 2.0 * Delta + s	  Real lambda_nue_n  = prefactor1 * (e_nue  + 2.0 * Delta + s
  Real lambda_nueb_p = prefactor2 * (e_nueb + 2.0 * Delta + s	  Real lambda_nueb_p = prefactor2 * (e_nueb + 2.0 * Delta + s
  Real lambda_pos_n  = prefactor * std::pow(T,5.0) * F4_e;	  Real lambda_pos_n  = prefactor * std::pow(T,5.0) * F4_e;
  Real lambda_ele_p  = prefactor * std::pow(T,5.0) * F4_p;	  Real lambda_ele_p  = prefactor * std::pow(T,5.0) * F4_p;

  // Sink term from QW 1996 in s^-1				  // Sink term from QW 1996 in s^-1
  Real Sink = Ye * (lambda_nue_n + lambda_pos_n + lambda_nueb	  Real Sink = Ye * (lambda_nue_n + lambda_pos_n + lambda_nueb
//  if(r<30.2e5) {						//  if(r<30.2e5) {
//    std::cout << "--SINK------------------------------" << 	//    std::cout << "--SINK------------------------------" << 
//    std::cout << "Sink          = " << Sink << " s^-1" << s	//    std::cout << "Sink          = " << Sink << " s^-1" << s
//    std::cout << "x             = " << x    << std::endl;	//    std::cout << "x             = " << x    << std::endl;
//    std::cout << "lambda_nue_n  = " << lambda_nue_n  << " s	//    std::cout << "lambda_nue_n  = " << lambda_nue_n  << " s
//    std::cout << "lambda_pos_n  = " << lambda_pos_n  << " s	//    std::cout << "lambda_pos_n  = " << lambda_pos_n  << " s
//    std::cout << "lambda_nueb_p = " << lambda_nueb_p << " s	//    std::cout << "lambda_nueb_p = " << lambda_nueb_p << " s
//    std::cout << "lambda_ele_p  = " << lambda_ele_p  << " s	//    std::cout << "lambda_ele_p  = " << lambda_ele_p  << " s
//    std::cout << "eta_e         = " << eta_e        << std:	//    std::cout << "eta_e         = " << eta_e        << std:
//    std::cout << "F4_e          = " << F4_e         << std:	//    std::cout << "F4_e          = " << F4_e         << std:
//    std::cout << "T             = " << T            << " Me	//    std::cout << "T             = " << T            << " Me
//    std::cout << "Ye            = " << Ye           << std:	//    std::cout << "Ye            = " << Ye           << std:
//    std::cout << "r            = " << r            << " cm"	//    std::cout << "r            = " << r            << " cm"
//    std::cout << "--------------------------------------" <	//    std::cout << "--------------------------------------" <
//  }								//  }
  return Sink;							  return Sink;
}								}


// Ye source function for scalar Ye (Scheck et al. 2006)	// Ye source function for scalar Ye (Scheck et al. 2006)
Real YeSourceHEOS(Real temp, Real ye, Real rho, Real r){	Real YeSourceHEOS(Real temp, Real ye, Real rho, Real r){
  // Returns YeDot_source in s^-1 units				  // Returns YeDot_source in s^-1 units
  // Temperature argument is in MeV				  // Temperature argument is in MeV
  // Define constants						  // Define constants
  Real alpha    = 1.26;                                      	  Real alpha    = 1.26;                                      
  Real Delta    = 1.293;                                     	  Real Delta    = 1.293;                                     
  Real mn       = 1.6749286e-24;                             	  Real mn       = 1.6749286e-24;                             
  Real me       = 9.1093897e-28;                             	  Real me       = 9.1093897e-28;                             
  Real hbar     = 6.582119569e-22;                           	  Real hbar     = 6.582119569e-22;                           
  Real c        = 2.99792458e10;                             	  Real c        = 2.99792458e10;                             
  Real erg2MeV  = 6.24151e5;                                 	  Real erg2MeV  = 6.24151e5;                                 
  Real MeV2erg  = 1.6021773e-6;                              	  Real MeV2erg  = 1.6021773e-6;                              
  Real kbol_MeV = 8.61733326e-11;                            	  Real kbol_MeV = 8.61733326e-11;                            
  Real kbol_erg = 1.3806504e-16;                             	  Real kbol_erg = 1.3806504e-16;                             
  Real sigma_0  = 1.76e-44;                                  	  Real sigma_0  = 1.76e-44;                                  
  Real sigma    = 1.0 / 4.0 * (3.0 * std::pow(alpha,2) + 1) *	  Real sigma    = 1.0 / 4.0 * (3.0 * std::pow(alpha,2) + 1) *

  // Eta_e parameters						  // Eta_e parameters
  Real fnu    = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0 / r,	  Real fnu    = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0 / r,
  Real Tprime = temp / (hbar * c);                           	  Real Tprime = temp / (hbar * c);                           
  Real Terg   = temp * MeV2erg;                              	  Real Terg   = temp * MeV2erg;                              
  Real tfact  = std::pow(27.0 * ye * rho + std::pow(3.0,0.5) 	  Real tfact  = std::pow(27.0 * ye * rho + std::pow(3.0,0.5) 
                         243.0 * std::pow(ye,2) * std::pow(rh	                         243.0 * std::pow(ye,2) * std::pow(rh

  // Electron chemical potential				  // Electron chemical potential
  Real eta_e = std::pow(12.0 * PI,1.0/3.0) * (std::pow(PI * m	  Real eta_e = std::pow(12.0 * PI,1.0/3.0) * (std::pow(PI * m
                        PI * std::pow(Tprime,2) * mn * std::p	                        PI * std::pow(Tprime,2) * mn * std::p

  // Composition densities (n_e and n_pos are given by equati	  // Composition densities (n_e and n_pos are given by equati
  Real nb    = rho / mn;                                     	  Real nb    = rho / mn;                                     
  Real n_e   = 8.0 * PI / std::pow(hbar * 2.0 * PI * c,3) * s	  Real n_e   = 8.0 * PI / std::pow(hbar * 2.0 * PI * c,3) * s
  Real n_pos = 8.0 * PI / std::pow(hbar * 2.0 * PI * c,3) * s	  Real n_pos = 8.0 * PI / std::pow(hbar * 2.0 * PI * c,3) * s
  Real n_p   = n_e;                                          	  Real n_p   = n_e;                                          

  // Neutrino energy moments given by D.42, assume eta_nu = 0	  // Neutrino energy moments given by D.42, assume eta_nu = 0
  Real Tnue    = eps_nue  / (kbol_MeV)       * (fermi(2,0) / 	  Real Tnue    = eps_nue  / (kbol_MeV)       * (fermi(2,0) / 
  Real EpsNue2 = std::pow(Tnue * kbol_erg,2) * (fermi(4,0) / 	  Real EpsNue2 = std::pow(Tnue * kbol_erg,2) * (fermi(4,0) / 
  Real EpsNue1 = Tnue * kbol_erg             * (fermi(3,0) / 	  Real EpsNue1 = Tnue * kbol_erg             * (fermi(3,0) / 

  // Positron energy moments given by D.52			  // Positron energy moments given by D.52
  Real EpsPositron2 = std::pow(temp * MeV2erg,2) * (fermi(4,-	  Real EpsPositron2 = std::pow(temp * MeV2erg,2) * (fermi(4,-
  Real EpsPositron1 = temp * MeV2erg             * (fermi(3,-	  Real EpsPositron1 = temp * MeV2erg             * (fermi(3,-

  // Reaction rates						  // Reaction rates
  Real lambda_nue_n = sigma * c * (L_nue * std::pow(10,51)) /	  Real lambda_nue_n = sigma * c * (L_nue * std::pow(10,51)) /
                                  (EpsNue2 + 2.0 * Delta * Me	                                  (EpsNue2 + 2.0 * Delta * Me
  Real lambda_pos_n = 0.5 * sigma * c * nb * n_pos *		  Real lambda_pos_n = 0.5 * sigma * c * nb * n_pos *
                                  (EpsPositron2 + 2.0 * Delta	                                  (EpsPositron2 + 2.0 * Delta

  // Source term						  // Source term
  Real source = 1.0 / nb * (lambda_nue_n + lambda_pos_n); // 	  Real source = 1.0 / nb * (lambda_nue_n + lambda_pos_n); // 
  return source;						  return source;

}								}

// Ye sink function for scalar Ye (Scheck et al. 2006)		// Ye sink function for scalar Ye (Scheck et al. 2006)
Real YeSinkHEOS(Real temp, Real ye, Real rho, Real r){		Real YeSinkHEOS(Real temp, Real ye, Real rho, Real r){
  // Returns Yedot_sink in s^-1 units				  // Returns Yedot_sink in s^-1 units
  // Temperature argument is in MeV				  // Temperature argument is in MeV
  // Define constants						  // Define constants
  Real alpha    = 1.26;                                      	  Real alpha    = 1.26;                                      
  Real Delta    = 1.293;                                     	  Real Delta    = 1.293;                                     
  Real mn       = 1.6749286e-24;                             	  Real mn       = 1.6749286e-24;                             
  Real me       = 9.1093897e-28;                             	  Real me       = 9.1093897e-28;                             
  Real hbar     = 6.582119569e-22;                           	  Real hbar     = 6.582119569e-22;                           
  Real c        = 2.99792458e10;                             	  Real c        = 2.99792458e10;                             
  Real erg2MeV  = 6.24151e5;                                 	  Real erg2MeV  = 6.24151e5;                                 
  Real MeV2erg  = 1.6021773e-6;                              	  Real MeV2erg  = 1.6021773e-6;                              
  Real kbol_MeV = 8.61733326e-11;                            	  Real kbol_MeV = 8.61733326e-11;                            
  Real kbol_erg = 1.3806504e-16;                             	  Real kbol_erg = 1.3806504e-16;                             
  Real sigma_0  = 1.76e-44;                                  	  Real sigma_0  = 1.76e-44;                                  
  Real sigma    = 1.0 / 4.0 * (3.0 * alpha * alpha + 1) * sig	  Real sigma    = 1.0 / 4.0 * (3.0 * alpha * alpha + 1) * sig

  // Eta_e parameters						  // Eta_e parameters
  Real fnu    = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0 / r,	  Real fnu    = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0 / r,
  Real Tprime = temp / (hbar * c);                           	  Real Tprime = temp / (hbar * c);                           
  Real Terg   = temp * MeV2erg;                              	  Real Terg   = temp * MeV2erg;                              
  Real tfact  = std::pow(27.0 * ye * rho + std::pow(3.0,0.5) 	  Real tfact  = std::pow(27.0 * ye * rho + std::pow(3.0,0.5) 
                         243.0 * std::pow(ye,2) * std::pow(rh	                         243.0 * std::pow(ye,2) * std::pow(rh

  // Electron chemical potential				  // Electron chemical potential
  Real eta_e    = std::pow(12.0 * PI,1.0/3.0) * (std::pow(PI 	  Real eta_e    = std::pow(12.0 * PI,1.0/3.0) * (std::pow(PI 
                           PI * std::pow(Tprime,2) * mn * std	                           PI * std::pow(Tprime,2) * mn * std

  // Composition densities (n_e and n_pos are given by equati	  // Composition densities (n_e and n_pos are given by equati
  Real nb    = rho / mn;                                     	  Real nb    = rho / mn;                                     
  Real n_e   = 8.0 * PI / std::pow(hbar * 2.0 * PI * c,3) * s	  Real n_e   = 8.0 * PI / std::pow(hbar * 2.0 * PI * c,3) * s
  Real n_pos = 8.0 * PI / std::pow(hbar * 2.0 * PI * c,3) * s	  Real n_pos = 8.0 * PI / std::pow(hbar * 2.0 * PI * c,3) * s
  Real n_p   = n_e;                                          	  Real n_p   = n_e;                                          

  // Neutrino energy moments given by D.42, assume eta_nu = 0	  // Neutrino energy moments given by D.42, assume eta_nu = 0
  Real Tnue    = eps_nue  / (kbol_MeV)       * (fermi(2,0) / 	  Real Tnue    = eps_nue  / (kbol_MeV)       * (fermi(2,0) / 
  Real EpsNue2 = std::pow(Tnue * kbol_erg,2) * (fermi(4,0) / 	  Real EpsNue2 = std::pow(Tnue * kbol_erg,2) * (fermi(4,0) / 
  Real EpsNue1 = Tnue * kbol_erg             * (fermi(3,0) / 	  Real EpsNue1 = Tnue * kbol_erg             * (fermi(3,0) / 

  // Neutrino energy moments given by D.43, assume eta_nu = 0	  // Neutrino energy moments given by D.43, assume eta_nu = 0
  Real Tnueb        = eps_nueb  / (kbol_MeV)       * (fermi(2	  Real Tnueb        = eps_nueb  / (kbol_MeV)       * (fermi(2
  Real EpsNueb2Star = std::pow(Tnueb * kbol_erg,2) * (fermi(4	  Real EpsNueb2Star = std::pow(Tnueb * kbol_erg,2) * (fermi(4
  Real EpsNueb1Star = Tnueb * kbol_erg             * (fermi(3	  Real EpsNueb1Star = Tnueb * kbol_erg             * (fermi(3
  Real EpsNueb0Star = 1.0                          * (fermi(2	  Real EpsNueb0Star = 1.0                          * (fermi(2
  Real EpsNueb1     = Tnueb * kbol_erg             * (fermi(3	  Real EpsNueb1     = Tnueb * kbol_erg             * (fermi(3

  // Positron energy moments given by D.52			  // Positron energy moments given by D.52
  Real EpsPositron2 = std::pow(temp * MeV2erg,2) * (fermi(4,-	  Real EpsPositron2 = std::pow(temp * MeV2erg,2) * (fermi(4,-
  Real EpsPositron1 = temp * MeV2erg             * (fermi(3,-	  Real EpsPositron1 = temp * MeV2erg             * (fermi(3,-

  // Electron energy moments given by D.53			  // Electron energy moments given by D.53
  Real EpsElectron2Star = std::pow(temp * MeV2erg,2) * (fermi	  Real EpsElectron2Star = std::pow(temp * MeV2erg,2) * (fermi
  Real EpsElectron1Star = temp * MeV2erg             * (fermi	  Real EpsElectron1Star = temp * MeV2erg             * (fermi
  Real EpsElectron0Star = 1.0                        * (fermi	  Real EpsElectron0Star = 1.0                        * (fermi

  // Reactions rates						  // Reactions rates
  Real lambda_nue_n  = sigma * c * (L_nue * std::pow(10,51)) 	  Real lambda_nue_n  = sigma * c * (L_nue * std::pow(10,51)) 
                      (EpsNue2 + 2.0 * Delta * MeV2erg * EpsN	                      (EpsNue2 + 2.0 * Delta * MeV2erg * EpsN
  Real lambda_pos_n  = 0.5 * sigma * c * nb * n_pos *		  Real lambda_pos_n  = 0.5 * sigma * c * nb * n_pos *
                      (EpsPositron2 + 2.0 * Delta * MeV2erg *	                      (EpsPositron2 + 2.0 * Delta * MeV2erg *
  Real lambda_nueb_p = sigma * c * (L_nueb * std::pow(10,51))	  Real lambda_nueb_p = sigma * c * (L_nueb * std::pow(10,51))
                      (EpsNueb2Star + 2.0 * Delta * MeV2erg *	                      (EpsNueb2Star + 2.0 * Delta * MeV2erg *
  Real lambda_ele_p  = 0.5 * sigma * c * nb * n_e *		  Real lambda_ele_p  = 0.5 * sigma * c * nb * n_e *
                      (EpsElectron2Star + 2.0 * Delta * MeV2e	                      (EpsElectron2Star + 2.0 * Delta * MeV2e

  // Sink term							  // Sink term
  Real sink = 1.0 / nb * ye * (lambda_nue_n + lambda_pos_n + 	  Real sink = 1.0 / nb * ye * (lambda_nue_n + lambda_pos_n + 
  return sink;							  return sink;
}								}

// Ye source function for scalar Ye				// Ye source function for scalar Ye
Real YeSourceQW(Real temp, Real ye, Real x, Real Rho) {		Real YeSourceQW(Real temp, Real ye, Real x, Real Rho) {
  // Returns Sources for Yedot=vdYe/dr (First part of RHS of 	  // Returns Sources for Yedot=vdYe/dr (First part of RHS of 
  // Temperature argument is in MeV				  // Temperature argument is in MeV
  // Define constants						  // Define constants
  Real alpha    = 1.26;                                // Cou	  Real alpha    = 1.26;                                // Cou
  Real G_F      = 1.1663787e-5 * std::pow(1.0e3,-2);   // Fer	  Real G_F      = 1.1663787e-5 * std::pow(1.0e3,-2);   // Fer
  Real Delta    = 1.293;                               // neu	  Real Delta    = 1.293;                               // neu
  Real hbar     = 6.582119569e-22;                     // Pla	  Real hbar     = 6.582119569e-22;                     // Pla
  Real c        = 2.99792458e10;                       // Lig	  Real c        = 2.99792458e10;                       // Lig
  Real erg2MeV  = 6.24151e5;                           // con	  Real erg2MeV  = 6.24151e5;                           // con
  Real kbol_MeV = 8.61733326*std::pow(10,-11);         // Bol	  Real kbol_MeV = 8.61733326*std::pow(10,-11);         // Bol
  Real lum      = std::pow(10,51);                     // 10^	  Real lum      = std::pow(10,51);                     // 10^

  // Neutrino Energy moments (using Scheck to define these)	  // Neutrino Energy moments (using Scheck to define these)
  // Neutrino energy moments given by D.42, assume eta_nu = 0	  // Neutrino energy moments given by D.42, assume eta_nu = 0
  Real Tnue         = eps_nue  / (kbol_MeV)        * (fermi(2	  Real Tnue         = eps_nue  / (kbol_MeV)        * (fermi(2
  Real Tnueb        = eps_nueb / (kbol_MeV)        * (fermi(2	  Real Tnueb        = eps_nueb / (kbol_MeV)        * (fermi(2
  Real EpsNue2      = std::pow(Tnue  * kbol_MeV,2) * (fermi(4	  Real EpsNue2      = std::pow(Tnue  * kbol_MeV,2) * (fermi(4
  Real EpsNueb2     = std::pow(Tnueb * kbol_MeV,2) * (fermi(4	  Real EpsNueb2     = std::pow(Tnueb * kbol_MeV,2) * (fermi(4
  Real EpsNueb2Star = std::pow(Tnueb * kbol_MeV,2) * (fermi(4	  Real EpsNueb2Star = std::pow(Tnueb * kbol_MeV,2) * (fermi(4
  Real EpsNue1      = Tnue  * kbol_MeV             * (fermi(3	  Real EpsNue1      = Tnue  * kbol_MeV             * (fermi(3
  Real EpsNueb1     = Tnueb * kbol_MeV             * (fermi(3	  Real EpsNueb1     = Tnueb * kbol_MeV             * (fermi(3
  Real EpsNueb1Star = Tnueb * kbol_MeV             * (fermi(3	  Real EpsNueb1Star = Tnueb * kbol_MeV             * (fermi(3
  Real EpsNueb0Star = 1.0                          * (fermi(2	  Real EpsNueb0Star = 1.0                          * (fermi(2

  Real e_nue   = EpsNue2  / EpsNue1;  // MeV			  Real e_nue   = EpsNue2  / EpsNue1;  // MeV
  Real e_nueb  = EpsNueb2 / EpsNueb1; // MeV			  Real e_nueb  = EpsNueb2 / EpsNueb1; // MeV

  // Forward reaction rates					  // Forward reaction rates
  Real lambda_nue_n  = std::pow(hbar*c,2.0) * (1.0 + 3.0 * al	  Real lambda_nue_n  = std::pow(hbar*c,2.0) * (1.0 + 3.0 * al
                      * (e_nue + 2.0 * Delta + Delta * Delta 	                      * (e_nue + 2.0 * Delta + Delta * Delta 

  // Calculate Eta, send in T in K				  // Calculate Eta, send in T in K
  Real Eta = QWEta(Rho,temp/kbol_MeV,ye);			  Real Eta = QWEta(Rho,temp/kbol_MeV,ye);

  // Reverse reaction rates					  // Reverse reaction rates
  Real f4_0         = fermi(4.0,0.0);				  Real f4_0         = fermi(4.0,0.0);
  Real f4_eta       = fermi(4.0,Eta);				  Real f4_eta       = fermi(4.0,Eta);
  Real f4_negeta    = fermi(4.0,-1.0*Eta);			  Real f4_negeta    = fermi(4.0,-1.0*Eta);
  Real lambda_ele_p = 0.448 * std::pow(temp,5.0) * f4_eta    	  Real lambda_ele_p = 0.448 * std::pow(temp,5.0) * f4_eta    
  Real lambda_pos_n = 0.448 * std::pow(temp,5.0) * f4_negeta 	  Real lambda_pos_n = 0.448 * std::pow(temp,5.0) * f4_negeta 

  // Source term						  // Source term
  Real out = lambda_nue_n+lambda_pos_n;				  Real out = lambda_nue_n+lambda_pos_n;
  return out;							  return out;
}								}

// Ye sink function for scalar Ye				// Ye sink function for scalar Ye
Real YeSinkQW(Real temp, Real ye, Real x, Real Rho) {		Real YeSinkQW(Real temp, Real ye, Real x, Real Rho) {
  // Returns Ye sink for Yedot=v*dYe/dr (equation 7 in Qian &	  // Returns Ye sink for Yedot=v*dYe/dr (equation 7 in Qian &
  // Temperature argument is in MeV				  // Temperature argument is in MeV
  // Define constants						  // Define constants
  Real alpha    = 1.26;                                // Cou	  Real alpha    = 1.26;                                // Cou
  Real G_F      = 1.1663787e-5 * std::pow(1.0e3,-2); //std::p	  Real G_F      = 1.1663787e-5 * std::pow(1.0e3,-2); //std::p
  Real Delta    = 1.293;                               // neu	  Real Delta    = 1.293;                               // neu
  Real hbar     = 6.582119569e-22;                     // Pla	  Real hbar     = 6.582119569e-22;                     // Pla
  Real c        = 2.99792458e10;                       // Lig	  Real c        = 2.99792458e10;                       // Lig
  Real erg2MeV  = 6.24151e5;                           // con	  Real erg2MeV  = 6.24151e5;                           // con
  Real kbol_MeV = 8.61733326*std::pow(10,-11);         // Bol	  Real kbol_MeV = 8.61733326*std::pow(10,-11);         // Bol
  Real lum      = std::pow(10,51);                     // 10^	  Real lum      = std::pow(10,51);                     // 10^

  // Neutrino Energy moments (using Scheck to define these)	  // Neutrino Energy moments (using Scheck to define these)
  // Neutrino energy moments given by D.42, assume eta_nu = 0	  // Neutrino energy moments given by D.42, assume eta_nu = 0
  Real Tnue         = eps_nue  / (kbol_MeV)        * (fermi(2	  Real Tnue         = eps_nue  / (kbol_MeV)        * (fermi(2
  Real Tnueb        = eps_nueb / (kbol_MeV)        * (fermi(2	  Real Tnueb        = eps_nueb / (kbol_MeV)        * (fermi(2
  Real EpsNue2      = std::pow(Tnue  * kbol_MeV,2) * (fermi(4	  Real EpsNue2      = std::pow(Tnue  * kbol_MeV,2) * (fermi(4
  Real EpsNueb2     = std::pow(Tnueb * kbol_MeV,2) * (fermi(4	  Real EpsNueb2     = std::pow(Tnueb * kbol_MeV,2) * (fermi(4
  Real EpsNueb2Star = std::pow(Tnueb * kbol_MeV,2) * (fermi(4	  Real EpsNueb2Star = std::pow(Tnueb * kbol_MeV,2) * (fermi(4
  Real EpsNue1      = Tnue  * kbol_MeV             * (fermi(3	  Real EpsNue1      = Tnue  * kbol_MeV             * (fermi(3
  Real EpsNueb1     = Tnueb * kbol_MeV             * (fermi(3	  Real EpsNueb1     = Tnueb * kbol_MeV             * (fermi(3
  Real EpsNueb1Star = Tnueb * kbol_MeV             * (fermi(3	  Real EpsNueb1Star = Tnueb * kbol_MeV             * (fermi(3
  Real EpsNueb0Star = 1.0                          * (fermi(2	  Real EpsNueb0Star = 1.0                          * (fermi(2

  Real e_nue   = EpsNue2  / EpsNue1;  // MeV			  Real e_nue   = EpsNue2  / EpsNue1;  // MeV
  Real e_nueb  = EpsNueb2 / EpsNueb1; // MeV			  Real e_nueb  = EpsNueb2 / EpsNueb1; // MeV

  // Forward reaction rates					  // Forward reaction rates
  Real lambda_nue_n  = std::pow(hbar*c,2.0) * (1.0 + 3.0 * al	  Real lambda_nue_n  = std::pow(hbar*c,2.0) * (1.0 + 3.0 * al
                      * (e_nue  + 2.0 * Delta + Delta * Delta	                      * (e_nue  + 2.0 * Delta + Delta * Delta
  Real lambda_nueb_p = std::pow(hbar*c,2.0) * (1.0 + 3.0 * al	  Real lambda_nueb_p = std::pow(hbar*c,2.0) * (1.0 + 3.0 * al
                      * (e_nueb - 2.0 * Delta + Delta * Delta	                      * (e_nueb - 2.0 * Delta + Delta * Delta

  // Calculate Eta, send in T in K				  // Calculate Eta, send in T in K
  Real Eta = QWEta(Rho,temp/kbol_MeV,ye);			  Real Eta = QWEta(Rho,temp/kbol_MeV,ye);

  // Reverse reaction rates					  // Reverse reaction rates
  Real f4_0         = fermi(4.0,0.0);				  Real f4_0         = fermi(4.0,0.0);
  Real f4_eta       = fermi(4.0,Eta);				  Real f4_eta       = fermi(4.0,Eta);
  Real f4_negeta    = fermi(4.0,-1.0*Eta);			  Real f4_negeta    = fermi(4.0,-1.0*Eta);
  Real lambda_ele_p = 0.448 * std::pow(temp,5.0) * f4_eta    	  Real lambda_ele_p = 0.448 * std::pow(temp,5.0) * f4_eta    
  Real lambda_pos_n = 0.448 * std::pow(temp,5.0) * f4_negeta 	  Real lambda_pos_n = 0.448 * std::pow(temp,5.0) * f4_negeta 

  // Sink term							  // Sink term
  Real out = (lambda_nue_n + lambda_pos_n + lambda_nueb_p + l	  Real out = (lambda_nue_n + lambda_pos_n + lambda_nueb_p + l
  return out;							  return out;
}								}

// Calculates the quasi equilibrium (nQSE) condition for Ye (	// Calculates the quasi equilibrium (nQSE) condition for Ye (
// This function exists mostly for diagnostic purposes.		// This function exists mostly for diagnostic purposes.
Real Ye_f(Real temp, Real ye, Real x){				Real Ye_f(Real temp, Real ye, Real x){
  // Returns Ye_f (equation 77 in Qian & Woosley 1996)		  // Returns Ye_f (equation 77 in Qian & Woosley 1996)
  // Temperature argument is in MeV				  // Temperature argument is in MeV
  // Define constants						  // Define constants
  Real alpha   = 1.26;                                // Coup	  Real alpha   = 1.26;                                // Coup
  Real G_F     = 1.1663787e-5 * std::pow(1.0e3,-2);   // Ferm	  Real G_F     = 1.1663787e-5 * std::pow(1.0e3,-2);   // Ferm
  Real e_nue   = 1.2 * eps_nue;                       // Elec	  Real e_nue   = 1.2 * eps_nue;                       // Elec
  Real e_nueb  = 1.2 * eps_nueb;                      // Elec	  Real e_nueb  = 1.2 * eps_nueb;                      // Elec
  Real Delta   = 1.293;                               // neut	  Real Delta   = 1.293;                               // neut
  Real hbar    = 6.582119569e-22;                     // Plan	  Real hbar    = 6.582119569e-22;                     // Plan
  Real c       = 2.99792458e10;                       // Ligh	  Real c       = 2.99792458e10;                       // Ligh
  Real erg2MeV = 6.24151e5;                           // conv	  Real erg2MeV = 6.24151e5;                           // conv
  Real lum     = std::pow(10,51);                     // 10^5	  Real lum     = std::pow(10,51);                     // 10^5

  // Forward reaction rates					  // Forward reaction rates
  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al	  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al
                      *(e_nue+2.0*Delta+1.2*Delta*Delta/e_nue	                      *(e_nue+2.0*Delta+1.2*Delta*Delta/e_nue
  Real lambda_nueb_p = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al	  Real lambda_nueb_p = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al
                      *(e_nueb-2.0*Delta+1.2*Delta*Delta/e_nu	                      *(e_nueb-2.0*Delta+1.2*Delta*Delta/e_nu

  // Ye_f term							  // Ye_f term
  Real out = (lambda_nue_n) / (lambda_nue_n + lambda_nueb_p);	  Real out = (lambda_nue_n) / (lambda_nue_n + lambda_nueb_p);
  return out;							  return out;
}								}

Real Heating_QW_Modified(Real x, Real Ye) {			Real Heating_QW_Modified(Real x, Real Ye) {
  // returns heating term from QW 1996				  // returns heating term from QW 1996
  Real sigma_0   = 1.76e-44;                                 	  Real sigma_0   = 1.76e-44;                                 
  Real alpha     = 1.26;                                     	  Real alpha     = 1.26;                                     
  Real mn        = 1.0 / Na;                                 	  Real mn        = 1.0 / Na;                                 
  Real E_e       = 0.511;                                    	  Real E_e       = 0.511;                                    
  Real F         = fermi(5,0.0) / fermi(3,0.0);              	  Real F         = fermi(5,0.0) / fermi(3,0.0);              
  Real kbT_nue   = eps_nue  * fermi(2,0.0) / fermi(3,0.0);   	  Real kbT_nue   = eps_nue  * fermi(2,0.0) / fermi(3,0.0);   
  Real kbT_nueb  = eps_nueb * fermi(2,0.0) / fermi(3,0.0);   	  Real kbT_nueb  = eps_nueb * fermi(2,0.0) / fermi(3,0.0);   
  Real erg2MeV   = 6.24151e5;                                	  Real erg2MeV   = 6.24151e5;                                
  Real MeV2erg   = 1.60218e-6;                               	  Real MeV2erg   = 1.60218e-6;                               
//  Real prefactor = sigma_0 * (1.0 + 3.0 * std::pow(alpha,2.	//  Real prefactor = sigma_0 * (1.0 + 3.0 * std::pow(alpha,2.
//                   (8.0 * PI * mn * std::pow(E_e,2.0) * 1.0	//                   (8.0 * PI * mn * std::pow(E_e,2.0) * 1.0
  Real prefactor = 9.65 * Na * 1.0e12;                       	  Real prefactor = 9.65 * Na * 1.0e12;                       
  Real Xn        = 1.0 - Ye;                                 	  Real Xn        = 1.0 - Ye;                                 
  Real Xp        = Ye;                                       	  Real Xp        = Ye;                                       

  // Heating term in erg s^-1 g^-1, L_nue and L_nueb are in 1	  // Heating term in erg s^-1 g^-1, L_nue and L_nueb are in 1
 // Real H = prefactor * F * (Xn * L_nue * std::pow(kbT_nue,2	 // Real H = prefactor * F * (Xn * L_nue * std::pow(kbT_nue,2
  Real H = MeV2erg * prefactor * F * (Xn * L_nue * std::pow(k	  Real H = MeV2erg * prefactor * F * (Xn * L_nue * std::pow(k
  return H;							  return H;
}								}

Real Cooling_QW_Modified(Real Rho, Real T, Real Ye) {		Real Cooling_QW_Modified(Real Rho, Real T, Real Ye) {
  // T is in MeV						  // T is in MeV
  // Returns cooling term from QW 1996				  // Returns cooling term from QW 1996
  Real kbol_MeV  = 8.61733326e-11;                           	  Real kbol_MeV  = 8.61733326e-11;                           
  Real sigma_0   = 1.76e-44;                                 	  Real sigma_0   = 1.76e-44;                                 
  Real alpha     = 1.26;                                     	  Real alpha     = 1.26;                                     
  Real mn        = 1.0 / Na;                                 	  Real mn        = 1.0 / Na;                                 
  Real E_e       = 0.511;                                    	  Real E_e       = 0.511;                                    
  Real h         = 4.1356677e-21;                            	  Real h         = 4.1356677e-21;                            
  Real c         = 2.99792458e10;                            	  Real c         = 2.99792458e10;                            
  Real prefactor = sigma_0 * (1.0 + 3.0 * std::pow(alpha,2.0)	  Real prefactor = sigma_0 * (1.0 + 3.0 * std::pow(alpha,2.0)
                  (std::pow(E_e,2.0) * mn * pow(h * c,3.0)); 	                  (std::pow(E_e,2.0) * mn * pow(h * c,3.0)); 
  Real MeV2erg   = 1.60218e-6;                               	  Real MeV2erg   = 1.60218e-6;                               
  Real Xn        = 1.0 - Ye;                                 	  Real Xn        = 1.0 - Ye;                                 
  Real Xp        = Ye;                                       	  Real Xp        = Ye;                                       

  // Calculate Eta, send in T in K				  // Calculate Eta, send in T in K
  Real eta_e = QWEta(Rho,T/kbol_MeV,Ye);			  Real eta_e = QWEta(Rho,T/kbol_MeV,Ye);
//  std::cout << "fermi(5,eta_e) = " << fermi(5.0,eta_e) << s	//  std::cout << "fermi(5,eta_e) = " << fermi(5.0,eta_e) << s
//  std::cout << "fermi(5,0)   = " << fermi(5,0) << std::endl	//  std::cout << "fermi(5,0)   = " << fermi(5,0) << std::endl

  // Cooling term in is erg s^-1 g^-1				  // Cooling term in is erg s^-1 g^-1
//  Real C = MeV2erg * prefactor * std::pow(T,6.0) * (Xn * fe	//  Real C = MeV2erg * prefactor * std::pow(T,6.0) * (Xn * fe
  Real C = MeV2erg * 2.27 * Na / fermi(5,0) * std::pow(T,6.0)	  Real C = MeV2erg * 2.27 * Na / fermi(5,0) * std::pow(T,6.0)
  return C;							  return C;
}								}

Real X_nucleon(Real rho, Real T) {				Real X_nucleon(Real rho, Real T) {
  // Temperature argument is in MeV				  // Temperature argument is in MeV
  Real rho_8    = rho / 1.0e8;    // Mass density in 10^8 g/c	  Real rho_8    = rho / 1.0e8;    // Mass density in 10^8 g/c
  Real xn       = 828.0 * std::pow(T,9.0/8.0) / std::pow(rho_	  Real xn       = 828.0 * std::pow(T,9.0/8.0) / std::pow(rho_
  return xn;							  return xn;
}								}

// Electron-type neutrino heating term from Scheck et al. 200	// Electron-type neutrino heating term from Scheck et al. 200
// Adapted to match Pejcha & Thompson (2012) formalism		// Adapted to match Pejcha & Thompson (2012) formalism
Real qdotScheck_H(Real ye, Real r) {				Real qdotScheck_H(Real ye, Real r) {
  // Returns heating in units of erg s^{-1} g^{-1} units	  // Returns heating in units of erg s^{-1} g^{-1} units
  // Physical constants:					  // Physical constants:
  const double c           = 2.99792458*std::pow(10,10); // c	  const double c           = 2.99792458*std::pow(10,10); // c
  const double mn          = 1.6749286*std::pow(10,-24); // g	  const double mn          = 1.6749286*std::pow(10,-24); // g
  const double MeV2erg     = 1.6021773*std::pow(10,-6);  // c	  const double MeV2erg     = 1.6021773*std::pow(10,-6);  // c
  const double melectron   = 9.1093897*std::pow(10,-28); // g	  const double melectron   = 9.1093897*std::pow(10,-28); // g
  const double delta       = 1.2935;                     // M	  const double delta       = 1.2935;                     // M
  const double fermi2      = fermi(2,0.0);			  const double fermi2      = fermi(2,0.0);
  const double fermi4      = fermi(4,0.0);			  const double fermi4      = fermi(4,0.0);
  const double fermi5      = fermi(5,0.0);			  const double fermi5      = fermi(5,0.0);
  const double fermi3      = fermi(3,0.0);			  const double fermi3      = fermi(3,0.0);
  const double fermifactor = fermi2 * fermi5 / ( fermi3 * fer	  const double fermifactor = fermi2 * fermi5 / ( fermi3 * fer
  const double alpha       = 1.254;				  const double alpha       = 1.254;
  const double sigmaweak   = 1.76*std::pow(10,-44)*(1.0+3.0*s	  const double sigmaweak   = 1.76*std::pow(10,-44)*(1.0+3.0*s

  Real Lnu       = L_nue;					  Real Lnu       = L_nue;
  Real fnu       = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0 /	  Real fnu       = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0 /
  Real sinkconst = sigmaweak * 0.5 * (Lnu * std::pow(10,51)) 	  Real sinkconst = sigmaweak * 0.5 * (Lnu * std::pow(10,51)) 

  // --- Absorption Term ---					  // --- Absorption Term ---
  Real q_abs  = sinkconst / mn * ((1.0 - ye) * (std::pow(eps_	  Real q_abs  = sinkconst / mn * ((1.0 - ye) * (std::pow(eps_
                                   2.0 * delta * MeV2erg * ep	                                   2.0 * delta * MeV2erg * ep
                                   std::pow(delta * MeV2erg,2	                                   std::pow(delta * MeV2erg,2
                                   3.0 * delta * MeV2erg * ep	                                   3.0 * delta * MeV2erg * ep
                                   3.0 * std::pow(delta * MeV	                                   3.0 * std::pow(delta * MeV

  return q_abs;							  return q_abs;
}								}

// Electron-type neutrino cooling term from Scheck et al. 200	// Electron-type neutrino cooling term from Scheck et al. 200
// Adapted to match Pejcha & Thompson (2012) formalism		// Adapted to match Pejcha & Thompson (2012) formalism
Real qdotScheck_C(Real temp, Real ye, Real rho, Real r) {	Real qdotScheck_C(Real temp, Real ye, Real rho, Real r) {
  // Returns cooling in units of erg s^{-1} g^{-1} units	  // Returns cooling in units of erg s^{-1} g^{-1} units
  // Temperature argument is in K				  // Temperature argument is in K
  const double c           = 2.99792458*std::pow(10,10);  // 	  const double c           = 2.99792458*std::pow(10,10);  // 
  const double mn          = 1.6749286*std::pow(10,-24);  // 	  const double mn          = 1.6749286*std::pow(10,-24);  // 
  const double MeV2erg     = 1.6021773*std::pow(10,-6);   // 	  const double MeV2erg     = 1.6021773*std::pow(10,-6);   // 
  const double melectron   = 9.1093897*std::pow(10,-28);  // 	  const double melectron   = 9.1093897*std::pow(10,-28);  // 
  const double delta       = 1.2935;                      // 	  const double delta       = 1.2935;                      // 
  const double kbol_erg    = 1.3806504*std::pow(10,-16);  // 	  const double kbol_erg    = 1.3806504*std::pow(10,-16);  // 
  const double hbar        = 1.05457266*std::pow(10,-27); // 	  const double hbar        = 1.05457266*std::pow(10,-27); // 
  const double alpha       = 1.254;				  const double alpha       = 1.254;
  const double sigmaweak   = 1.76*std::pow(10,-44)*(1.0+3.0*s	  const double sigmaweak   = 1.76*std::pow(10,-44)*(1.0+3.0*s

  Real fnu         = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0	  Real fnu         = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0
  Real Tprime      = temp * kbol_erg / (hbar * c); // cm^-1	  Real Tprime      = temp * kbol_erg / (hbar * c); // cm^-1
  Real Terg        = temp * kbol_erg; // erg			  Real Terg        = temp * kbol_erg; // erg
  Real tfact       = std::pow(27.0 * ye * rho + std::pow(3.0,	  Real tfact       = std::pow(27.0 * ye * rho + std::pow(3.0,
                              243.0 * std::pow(ye,2) * std::p	                              243.0 * std::pow(ye,2) * std::p
  Real eta_e       = std::pow(12.0 * PI,1.0/3.0) * (std::pow(	  Real eta_e       = std::pow(12.0 * PI,1.0/3.0) * (std::pow(
                              PI * std::pow(Tprime,2) * mn * 	                              PI * std::pow(Tprime,2) * mn * 
  Real sourceconst = sigmaweak * 0.5 * c * std::pow(Tprime,3)	  Real sourceconst = sigmaweak * 0.5 * c * std::pow(Tprime,3)

  // --- Emission Term ----					  // --- Emission Term ----
  Real q_em   = sourceconst * (ye * (std::pow(Terg,3) * fermi	  Real q_em   = sourceconst * (ye * (std::pow(Terg,3) * fermi
                              2.0 * delta * MeV2erg * std::po	                              2.0 * delta * MeV2erg * std::po
                              std::pow(delta * MeV2erg,2) * T	                              std::pow(delta * MeV2erg,2) * T
                              (1.0 - ye) * (std::pow(Terg,3) 	                              (1.0 - ye) * (std::pow(Terg,3) 
                              3.0 * std::pow(delta * MeV2erg,	                              3.0 * std::pow(delta * MeV2erg,

  return q_em;							  return q_em;
}								}

// Free nucleon mass fraction from QW1996 equation 62		// Free nucleon mass fraction from QW1996 equation 62
Real Xn(Real rho, Real T) {					Real Xn(Real rho, Real T) {
  // Temperature argument is in MeV				  // Temperature argument is in MeV
  Real rho_8    = rho / 1.0e8;    // Mass density in 10^8 g/c	  Real rho_8    = rho / 1.0e8;    // Mass density in 10^8 g/c
  Real xn       = 828.0 * std::pow(T,9.0/8.0) / std::pow(rho_	  Real xn       = 828.0 * std::pow(T,9.0/8.0) / std::pow(rho_
  return xn;							  return xn;
}								}

// Temperature at which heating=cooling for Qian & Woosley (1	// Temperature at which heating=cooling for Qian & Woosley (1
inline Real zeroQ_temp(Real x, Real ye, Real time=0.0) {	inline Real zeroQ_temp(Real x, Real ye, Real time=0.0) {
  // Smoothly transition from 0 at t<=t_L_0 to 1 at t>=t_L_1	  // Smoothly transition from 0 at t<=t_L_0 to 1 at t>=t_L_1
  Real f           = (time <= t_L_0) ? 0.0 :			  Real f           = (time <= t_L_0) ? 0.0 :
                    ((time >= t_L_1) ? 1.0 : SQR(std::sin((ti	                    ((time >= t_L_1) ? 1.0 : SQR(std::sin((ti
  Real Coeff_nu    = Coeff_nu_0 + f * dCoeff_nu;		  Real Coeff_nu    = Coeff_nu_0 + f * dCoeff_nu;
  Real Coeff_nubar = Coeff_nubar_0 + f * dCoeff_nubar;		  Real Coeff_nubar = Coeff_nubar_0 + f * dCoeff_nubar;
  return std::pow(1e12*9.65/2.27*((1.-ye)*Coeff_nu+ye*Coeff_n	  return std::pow(1e12*9.65/2.27*((1.-ye)*Coeff_nu+ye*Coeff_n
                  1./6.) / 8.6173e-11;				                  1./6.) / 8.6173e-11;
}								}

// Performs double NR procedure to simultaneously determine Y	// Performs double NR procedure to simultaneously determine Y
// This procedure uses Scheck et al. (2006) qdot (emission an	// This procedure uses Scheck et al. (2006) qdot (emission an
//void Single_NR(Real Arr[],Real r,Real rho0) {			//void Single_NR(Real Arr[],Real r,Real rho0) {
//  Real x_0      = std::pow(1.0 - std::pow(r_0 / r,2), 0.5);	//  Real x_0      = std::pow(1.0 - std::pow(r_0 / r,2), 0.5);
//  Real kbol_MeV = 8.61733326*std::pow(10,-11);             	//  Real kbol_MeV = 8.61733326*std::pow(10,-11);             
//  Real T0       = tgs;                                     	//  Real T0       = tgs;                                     
//  Real Y0       = ye_0;                                    	//  Real Y0       = ye_0;                                    
//								//
//  for(int i=0; i<=maxcsNR; i++) {				//  for(int i=0; i<=maxcsNR; i++) {
//    // Differential terms					//    // Differential terms
//    Real deltaT0         = dtg*T0;              // K		//    Real deltaT0         = dtg*T0;              // K
//    Real dT              = (T0+deltaT0) - (T0); // K		//    Real dT              = (T0+deltaT0) - (T0); // K
//								//
//    // Scale terms						//    // Scale terms
//    Real H0         = qdotScheck_H(Y0,r); // erg/s/g		//    Real H0         = qdotScheck_H(Y0,r); // erg/s/g
//								//
//    // Original function					//    // Original function
//    Real qdot     = (qdotScheck_H(Y0,r) - qdotScheck_C(T0,Y	//    Real qdot     = (qdotScheck_H(Y0,r) - qdotScheck_C(T0,Y
//								//
//    // Function with differential term			//    // Function with differential term
//    Real dqdot_T  = (qdotScheck_H(Y0,r) - qdotScheck_C(T0+d	//    Real dqdot_T  = (qdotScheck_H(Y0,r) - qdotScheck_C(T0+d
//								//
//    // Rescale Functions					//    // Rescale Functions
//    Real f    = qdot     / H0;				//    Real f    = qdot     / H0;
//    Real f_dT = dqdot_T  / H0;				//    Real f_dT = dqdot_T  / H0;
//								//
//    // Define derivative					//    // Define derivative
//    Real dqdotdT = (f_dT - f) / (dT * kbol_MeV);        // 	//    Real dqdotdT = (f_dT - f) / (dT * kbol_MeV);        // 
//								//
//    // Newton-Raphson step					//    // Newton-Raphson step
//    Real T1 = T0 - modsNR * f * (1.0 / dqdotdT) / kbol_MeV;	//    Real T1 = T0 - modsNR * f * (1.0 / dqdotdT) / kbol_MeV;
//								//
//    // Test convergence					//    // Test convergence
//    if(fabs(T1-T0)/fabs(T1)<tolsNR) {				//    if(fabs(T1-T0)/fabs(T1)<tolsNR) {
//      Arr[0] = T1;						//      Arr[0] = T1;
//      break;							//      break;
//    } else {							//    } else {
//      T0 = T1;						//      T0 = T1;
//    }								//    }
//    if(i==maxcsNR){						//    if(i==maxcsNR){
//      std::cout << "(Newton-Raphson for T) Convergence fail	//      std::cout << "(Newton-Raphson for T) Convergence fail
//      Arr[0]=T0;						//      Arr[0]=T0;
//    }								//    }
//  }								//  }
//  return;							//  return;
//}								//}

void Single_NR(Real Arr[], Real r, Real rho0, Real Y0) {	void Single_NR(Real Arr[], Real r, Real rho0, Real Y0) {
  Real x_0      = std::pow(1.0 - std::pow(r_0 / r,2), 0.5); /	  Real x_0      = std::pow(1.0 - std::pow(r_0 / r,2), 0.5); /
  Real kbol_MeV = 8.61733326*std::pow(10,-11);              /	  Real kbol_MeV = 8.61733326*std::pow(10,-11);              /
  Real T0       = tgs;                                      /	  Real T0       = tgs;                                      /
//  Real Y0       = ye_0;                                    	//  Real Y0       = ye_0;                                    
//  Real rho0     = rho_0;					//  Real rho0     = rho_0;

  for(int i=0; i<=maxcsNR; i++) {				  for(int i=0; i<=maxcsNR; i++) {
    // Differential terms					    // Differential terms
    Real deltaT0 = dtg*T0;            // K			    Real deltaT0 = dtg*T0;            // K
    Real dT      = (T0+deltaT0) - (T0); // K			    Real dT      = (T0+deltaT0) - (T0); // K

    // Scale term						    // Scale term
    Real H0 = Heating_QW_Modified(x_0,Y0); // erg/s/g		    Real H0 = Heating_QW_Modified(x_0,Y0); // erg/s/g

    // Original function					    // Original function
    Real qdot = Heating_QW_Modified(x_0,Y0) - Cooling_QW_Modi	    Real qdot = Heating_QW_Modified(x_0,Y0) - Cooling_QW_Modi

    // Function with differential term				    // Function with differential term
    Real dqdot_T = Heating_QW_Modified(x_0,Y0) - Cooling_QW_M	    Real dqdot_T = Heating_QW_Modified(x_0,Y0) - Cooling_QW_M

    // Rescale Functions					    // Rescale Functions
    Real f    = qdot     / H0;					    Real f    = qdot     / H0;
    Real f_dT = dqdot_T  / H0;					    Real f_dT = dqdot_T  / H0;

    // Define derivative					    // Define derivative
    Real dqdotdT = (f_dT - f) / (dT * kbol_MeV);        // Me	    Real dqdotdT = (f_dT - f) / (dT * kbol_MeV);        // Me

    // Newton-Raphson step					    // Newton-Raphson step
    Real T1 = T0 - modsNR * f * (1.0 / dqdotdT) / kbol_MeV;  	    Real T1 = T0 - modsNR * f * (1.0 / dqdotdT) / kbol_MeV;  

    // Test convergence						    // Test convergence
    if(fabs(T1-T0)/fabs(T1)<tolsNR) {				    if(fabs(T1-T0)/fabs(T1)<tolsNR) {
      Arr[0] = T1;						      Arr[0] = T1;
//      Real qdotZero = Heating_QW_Modified(x_0,Y0) - Cooling	//      Real qdotZero = Heating_QW_Modified(x_0,Y0) - Cooling
//      std::cout << "NR Converged: qdot = " << qdotZero << "	//      std::cout << "NR Converged: qdot = " << qdotZero << "
//      std::cout << " " << std::endl;				//      std::cout << " " << std::endl;

//      std::cout << "Common NR W" << std::endl;		//      std::cout << "Common NR W" << std::endl;
//      std::cout << "Teq = " << T1 * kbol_MeV << " MeV" << s	//      std::cout << "Teq = " << T1 * kbol_MeV << " MeV" << s
//      std::cout << "dT increment = " << dtg_s << std::endl;	//      std::cout << "dT increment = " << dtg_s << std::endl;
//      std::cout << "tolerance    = " << tolsNR << std::endl	//      std::cout << "tolerance    = " << tolsNR << std::endl
//      std::cout << "|T1-T0|/|T1| = " << fabs(T1-T0)/fabs(T1	//      std::cout << "|T1-T0|/|T1| = " << fabs(T1-T0)/fabs(T1
      break;							      break;
    } else {							    } else {
//      std::cout << "|T1-T0|/|T1| = " << fabs(T1-T0)/fabs(T1	//      std::cout << "|T1-T0|/|T1| = " << fabs(T1-T0)/fabs(T1
//      std::cout << "T0           = " << T0 << " K" << std::	//      std::cout << "T0           = " << T0 << " K" << std::
//      std::cout << "T1           = " << T1 << " K" << std::	//      std::cout << "T1           = " << T1 << " K" << std::
//      std::cout << "qdot         = " << qdot << " erg/s/g" 	//      std::cout << "qdot         = " << qdot << " erg/s/g" 
      T0 = T1;							      T0 = T1;
    }								    }
    if(i==maxcsNR){						    if(i==maxcsNR){
      std::cout << "(Newton-Raphson for T) Convergence failed	      std::cout << "(Newton-Raphson for T) Convergence failed
      Arr[0]=T0;						      Arr[0]=T0;
    }								    }
  }								  }
  return;							  return;
}								}

void Double_NR(Real Arr[], Real ra, Real rho0) {		void Double_NR(Real Arr[], Real ra, Real rho0) {
  // Returns T_eq and Y_eq as Arr[0] and Arr[1] respectively.	  // Returns T_eq and Y_eq as Arr[0] and Arr[1] respectively.
  Real x_0      = std::pow(1.0 - std::pow(r_0 / ra,2), 0.5); 	  Real x_0      = std::pow(1.0 - std::pow(r_0 / ra,2), 0.5); 
  Real MeV      = 8.6173e-11;                                	  Real MeV      = 8.6173e-11;                                
  Real kbol_MeV = 8.61733326*std::pow(10,-11);               	  Real kbol_MeV = 8.61733326*std::pow(10,-11);               
  Real T0       = tg;                                        	  Real T0       = tg;                                        
  Real Y0       = yg;                                        	  Real Y0       = yg;                                        
  for(int i=0; i<=maxcdNR; i++){				  for(int i=0; i<=maxcdNR; i++){

    // Define differential terms				    // Define differential terms
    Real deltaT0 = dtg*T0;					    Real deltaT0 = dtg*T0;
    Real deltaY0 = dyg*Y0;					    Real deltaY0 = dyg*Y0;
    Real dYe     = (Y0+deltaY0) - (Y0);				    Real dYe     = (Y0+deltaY0) - (Y0);
    Real dT      = (T0+deltaT0) - (T0);				    Real dT      = (T0+deltaT0) - (T0);

    // Define scale terms					    // Define scale terms
    Real H0         = qdotScheck_H(Y0,ra);			    Real H0         = qdotScheck_H(Y0,ra);
    Real H0_dT      = qdotScheck_H(Y0,ra);			    Real H0_dT      = qdotScheck_H(Y0,ra);
    Real H0_dY      = qdotScheck_H(Y0+deltaY0,ra);		    Real H0_dY      = qdotScheck_H(Y0+deltaY0,ra);
    Real Source0    = YeSourceHEOS(T0*kbol_MeV,Y0,rho0,r_0);	    Real Source0    = YeSourceHEOS(T0*kbol_MeV,Y0,rho0,r_0);
    Real Source0_dT = YeSourceHEOS((T0+deltaT0)*kbol_MeV,Y0,r	    Real Source0_dT = YeSourceHEOS((T0+deltaT0)*kbol_MeV,Y0,r
    Real Source0_dY = YeSourceHEOS(T0*kbol_MeV,Y0+deltaY0,rho	    Real Source0_dY = YeSourceHEOS(T0*kbol_MeV,Y0+deltaY0,rho

    // Define 'original' source functions			    // Define 'original' source functions
    Real qdot    = (qdotScheck_H(Y0,ra) - qdotScheck_C(T0,Y0,	    Real qdot    = (qdotScheck_H(Y0,ra) - qdotScheck_C(T0,Y0,
    Real Yedot   = (YeSourceHEOS(T0*kbol_MeV,Y0,rho0,r_0) - Y	    Real Yedot   = (YeSourceHEOS(T0*kbol_MeV,Y0,rho0,r_0) - Y

    // Define source functions with differentials		    // Define source functions with differentials
    Real dqdot_T  = (qdotScheck_H(Y0,ra) - qdotScheck_C(T0+de	    Real dqdot_T  = (qdotScheck_H(Y0,ra) - qdotScheck_C(T0+de
    Real dqdot_Y  = (qdotScheck_H(Y0+deltaY0,ra) - qdotScheck	    Real dqdot_Y  = (qdotScheck_H(Y0+deltaY0,ra) - qdotScheck
    Real dYedot_T = (YeSourceHEOS((T0+deltaT0)*kbol_MeV,Y0,rh	    Real dYedot_T = (YeSourceHEOS((T0+deltaT0)*kbol_MeV,Y0,rh
    Real dYedot_Y = (YeSourceHEOS(T0*kbol_MeV,Y0+deltaY0,rho0	    Real dYedot_Y = (YeSourceHEOS(T0*kbol_MeV,Y0+deltaY0,rho0

    // Define rescaled source functions				    // Define rescaled source functions
    Real f    = qdot     / H0;					    Real f    = qdot     / H0;
    Real g    = Yedot    / Source0;				    Real g    = Yedot    / Source0;
    Real f_dT = dqdot_T  / H0; //H0_dT;				    Real f_dT = dqdot_T  / H0; //H0_dT;
    Real f_dY = dqdot_Y  / H0; //H0_dY;				    Real f_dY = dqdot_Y  / H0; //H0_dY;
    Real g_dT = dYedot_T / Source0; //Source0_dT;		    Real g_dT = dYedot_T / Source0; //Source0_dT;
    Real g_dY = dYedot_Y / Source0; //Source0_dY;		    Real g_dY = dYedot_Y / Source0; //Source0_dY;

    // Define rescaled source function derivatives		    // Define rescaled source function derivatives
    Real dqdotdT = (f_dT - f) / (dT*kbol_MeV);			    Real dqdotdT = (f_dT - f) / (dT*kbol_MeV);
    Real dqdotdY = (f_dY - f) / (dYe);				    Real dqdotdY = (f_dY - f) / (dYe);
    Real dYdotdT = (g_dT - g) / (dT*kbol_MeV);			    Real dYdotdT = (g_dT - g) / (dT*kbol_MeV);
    Real dYdotdY = (g_dY - g) / (dYe);				    Real dYdotdY = (g_dY - g) / (dYe);

    if(fabs(dqdotdT) < epsdNR || fabs(dqdotdY) < epsdNR || fa	    if(fabs(dqdotdT) < epsdNR || fabs(dqdotdY) < epsdNR || fa
       std::cout << "One of the derivatives is too small! (Do	       std::cout << "One of the derivatives is too small! (Do
       std::cout << "Returning guess T and Ye by default." <<	       std::cout << "Returning guess T and Ye by default." <<
       std::cout << "dqdotdT = " << dqdotdT << std::endl;	       std::cout << "dqdotdT = " << dqdotdT << std::endl;
       std::cout << "dqdotdY = " << dqdotdY << std::endl;	       std::cout << "dqdotdY = " << dqdotdY << std::endl;
       std::cout << "dYdotdT = " << dYdotdT << std::endl;	       std::cout << "dYdotdT = " << dYdotdT << std::endl;
       std::cout << "dYdotdY = " << dYdotdY << std::endl;	       std::cout << "dYdotdY = " << dYdotdY << std::endl;
       Arr[0] = T0;						       Arr[0] = T0;
       Arr[1] = Y0;						       Arr[1] = Y0;
       break;							       break;
    }								    }

    ////////////////////////////////////////////////////	    ////////////////////////////////////////////////////
    // Invert Jacobian to find delta terms:           //	    // Invert Jacobian to find delta terms:           //
    //           A          *   x       =   b         //	    //           A          *   x       =   b         //
    //                                                //	    //                                                //
    // [ dqdotdT  dqdotdY ]   [ delT  ]   [ f ]       //	    // [ dqdotdT  dqdotdY ]   [ delT  ]   [ f ]       //
    // [                  ] * [       ] = [   ]       //	    // [                  ] * [       ] = [   ]       //
    // [ dYdotdT  dYdotdY ]   [ delYe ]   [ g ]       //	    // [ dYdotdT  dYdotdY ]   [ delYe ]   [ g ]       //
    //                                                //	    //                                                //
    //                          x       = A^-1 * b    //	    //                          x       = A^-1 * b    //
    ////////////////////////////////////////////////////	    ////////////////////////////////////////////////////

    // Invert matrix A (2x2)					    // Invert matrix A (2x2)
    Real a      = dqdotdT;					    Real a      = dqdotdT;
    Real b      = dqdotdY;					    Real b      = dqdotdY;
    Real c      = dYdotdT;					    Real c      = dYdotdT;
    Real d      = dYdotdY;					    Real d      = dYdotdY;
    Real detA   = a*d - b*c;					    Real detA   = a*d - b*c;
    Real Ainv00 = 1.0/detA * (d);				    Real Ainv00 = 1.0/detA * (d);
    Real Ainv01 = 1.0/detA * (-1.0 * b);			    Real Ainv01 = 1.0/detA * (-1.0 * b);
    Real Ainv10 = 1.0/detA * (-1.0 * c);			    Real Ainv10 = 1.0/detA * (-1.0 * c);
    Real Ainv11 = 1.0/detA * (a);				    Real Ainv11 = 1.0/detA * (a);
    Real delT   = (f*Ainv00 + g*Ainv01) / kbol_MeV; // Return	    Real delT   = (f*Ainv00 + g*Ainv01) / kbol_MeV; // Return
    Real delYe  = f*Ainv10 + g*Ainv11;				    Real delYe  = f*Ainv10 + g*Ainv11;

    // Determine new T and Ye values. Minus sign is a typical	    // Determine new T and Ye values. Minus sign is a typical
    Real T1 = T0 - moddNR * delT;				    Real T1 = T0 - moddNR * delT;
    Real Y1 = Y0 - moddNR * delYe;				    Real Y1 = Y0 - moddNR * delYe;

    // Check if T and Ye simultaneously converge. If not, con	    // Check if T and Ye simultaneously converge. If not, con
    if(fabs(T1-T0)/fabs(T1) < toldNR && fabs(Y1-Y0)/fabs(Y1) 	    if(fabs(T1-T0)/fabs(T1) < toldNR && fabs(Y1-Y0)/fabs(Y1) 
        Arr[0] = T1;						        Arr[0] = T1;
        Arr[1] = Y1;						        Arr[1] = Y1;
     //   std::cout << "Double NR Success" << std::endl;	     //   std::cout << "Double NR Success" << std::endl;
        break;							        break;
    } else {							    } else {
      T0 = T1;							      T0 = T1;
      Y0 = Y1;							      Y0 = Y1;
    }								    }
    if(i==maxcdNR) {						    if(i==maxcdNR) {
      Arr[0] = tg; //T1;					      Arr[0] = tg; //T1;
      Arr[1] = yg; //Y1;					      Arr[1] = yg; //Y1;
    }								    }
  }								  }
  return;							  return;
}								}

// exists_test1 from https://stackoverflow.com/a/12774387/227	// exists_test1 from https://stackoverflow.com/a/12774387/227
inline bool exists (const std::string& name) {			inline bool exists (const std::string& name) {
    if (FILE *file = fopen(name.c_str(), "r")) {		    if (FILE *file = fopen(name.c_str(), "r")) {
        fclose(file);						        fclose(file);
        return true;						        return true;
    } else {							    } else {
        return false;						        return false;
    }								    }
}								}

//Heating/cooling source term					//Heating/cooling source term
void heat_cool(MeshBlock *pmb, const Real time, const Real dt	void heat_cool(MeshBlock *pmb, const Real time, const Real dt
               const AthenaArray<Real> &prim, const AthenaArr	               const AthenaArray<Real> &prim, const AthenaArr
               const AthenaArray<Real> &bcc, AthenaArray<Real	               const AthenaArray<Real> &bcc, AthenaArray<Real
               AthenaArray<Real> &cons_scalar);			               AthenaArray<Real> &cons_scalar);

// Boundary Condition						// Boundary Condition
void InflowInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaAr	void InflowInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaAr
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh);		                   int je, int ks, int ke, int ngh);
void InflowMdotInnerX1(MeshBlock *pmb, Coordinates *pco, Athe	void InflowMdotInnerX1(MeshBlock *pmb, Coordinates *pco, Athe
                       FaceField &b, Real time, Real dt, int 	                       FaceField &b, Real time, Real dt, int 
                       int je, int ks, int ke, int ngh);	                       int je, int ks, int ke, int ngh);
void HSEInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArray	void HSEInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArray
                FaceField &b, Real time, Real dt, int is, int	                FaceField &b, Real time, Real dt, int is, int
                int je, int ks, int ke, int ngh);		                int je, int ks, int ke, int ngh);
void HSE2InnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArra	void HSE2InnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArra
                 FaceField &b, Real time, Real dt, int is, in	                 FaceField &b, Real time, Real dt, int is, in
                 int je, int ks, int ke, int ngh);		                 int je, int ks, int ke, int ngh);
void OutflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaA	void OutflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaA
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh);		                   int je, int ks, int ke, int ngh);
void InflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaAr	void InflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaAr
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh);		                   int je, int ks, int ke, int ngh);

//-----------------------------------------------------------	//-----------------------------------------------------------
//! \fn void Mesh::InitUserMeshData(ParameterInput *pin)	//! \fn void Mesh::InitUserMeshData(ParameterInput *pin)
//  \brief Function to initialize problem-specific data in me	//  \brief Function to initialize problem-specific data in me
//  to initialize variables which are global to (and therefor	//  to initialize variables which are global to (and therefor
//  functions in this file.  Called in Mesh constructor.	//  functions in this file.  Called in Mesh constructor.

void Mesh::InitUserMeshData(ParameterInput *pin) {		void Mesh::InitUserMeshData(ParameterInput *pin) {
  EnrollUserExplicitSourceFunction(heat_cool);			  EnrollUserExplicitSourceFunction(heat_cool);
  // set outer BC						  // set outer BC
  if (pin->GetString("mesh", "ox1_bc").compare("user") == 0) 	  if (pin->GetString("mesh", "ox1_bc").compare("user") == 0) 
    if (Globals::my_rank == 0)					    if (Globals::my_rank == 0)
      printf("Using USER outer BC.\n");				      printf("Using USER outer BC.\n");
    EnrollUserBoundaryFunction(BoundaryFace::outer_x1, Inflow	    EnrollUserBoundaryFunction(BoundaryFace::outer_x1, Inflow
  }								  }
  // set inner BC						  // set inner BC
  int inner_BC_choice = pin->GetOrAddInteger("problem", "inne	  int inner_BC_choice = pin->GetOrAddInteger("problem", "inne
  if (inner_BC_choice == 0) {					  if (inner_BC_choice == 0) {
    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, Inflow	    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, Inflow
  } else if (inner_BC_choice == 1) {				  } else if (inner_BC_choice == 1) {
    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, Inflow	    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, Inflow
  } else if (inner_BC_choice == 2) {				  } else if (inner_BC_choice == 2) {
    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, HSEInn	    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, HSEInn
  } else if (inner_BC_choice == 3) {				  } else if (inner_BC_choice == 3) {
    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, HSE2In	    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, HSE2In
  } else {							  } else {
    std::stringstream msg;					    std::stringstream msg;
    msg << "### FATAL ERROR in Mesh::InitUserMeshData" << std	    msg << "### FATAL ERROR in Mesh::InitUserMeshData" << std
        << "Invalid inner BC choice (" << inner_BC_choice << 	        << "Invalid inner BC choice (" << inner_BC_choice << 
    ATHENA_ERROR(msg);						    ATHENA_ERROR(msg);
  }								  }
  printf("Using USER inner BC %d.\n", inner_BC_choice);		  printf("Using USER inner BC %d.\n", inner_BC_choice);

  Real inf     = std::numeric_limits<Real>::infinity();		  Real inf     = std::numeric_limits<Real>::infinity();

  // Problem quantities						  // Problem quantities
  mu       = pin->GetReal("problem","GM");			  mu       = pin->GetReal("problem","GM");
  rho_0    = pin->GetReal("problem","rho_0");			  rho_0    = pin->GetReal("problem","rho_0");
  rho_f    = pin->GetReal("problem","rho_f");			  rho_f    = pin->GetReal("problem","rho_f");
  v_f      = pin->GetReal("problem","v_f");			  v_f      = pin->GetReal("problem","v_f");
  p_f      = pin->GetReal("problem","p_f");			  p_f      = pin->GetReal("problem","p_f");
  r_0      = pin->GetReal("mesh","x1min");			  r_0      = pin->GetReal("mesh","x1min");
  inv_r2   = std::pow(r_0, -2);					  inv_r2   = std::pow(r_0, -2);
  Na       = pin->GetReal("problem","Na");			  Na       = pin->GetReal("problem","Na");
  Tc       = pin->GetReal("problem","T_cutoff");		  Tc       = pin->GetReal("problem","T_cutoff");
  B_0      = pin->GetReal("problem","B_0");			  B_0      = pin->GetReal("problem","B_0");
  B_0      = B_0/(std::pow(4.0*PI,0.5)); //convert to Lorentz	  B_0      = B_0/(std::pow(4.0*PI,0.5)); //convert to Lorentz
  alpha    = pin->GetReal("problem","alpha");			  alpha    = pin->GetReal("problem","alpha");
  t_rho0_0 = pin->GetOrAddReal("problem","t_rho0_perturb",inf	  t_rho0_0 = pin->GetOrAddReal("problem","t_rho0_perturb",inf
  pModify  = pin->GetOrAddReal("problem","pMod",1.0);		  pModify  = pin->GetOrAddReal("problem","pMod",1.0);
  Mach     = pin->GetOrAddReal("problem","MachNumber",1.0);	  Mach     = pin->GetOrAddReal("problem","MachNumber",1.0);

  // Passive scalar quantities					  // Passive scalar quantities
  ye_index     = pin->GetInteger("hydro","helm_ye_index");	  ye_index     = pin->GetInteger("hydro","helm_ye_index");
  t_index      = pin->GetInteger("hydro","helm_temp_index");	  t_index      = pin->GetInteger("hydro","helm_temp_index");
  nscalar_size = pin->GetInteger("hydro","nsSize");		  nscalar_size = pin->GetInteger("hydro","nsSize");
  ye_f         = pin->GetReal("hydro","Ye_f");			  ye_f         = pin->GetReal("hydro","Ye_f");
  ye_0         = pin->GetReal("hydro","Ye_0");			  ye_0         = pin->GetReal("hydro","Ye_0");

  // Quantities used for calculating optical depth		  // Quantities used for calculating optical depth
  g_a         = pin->GetReal("problem","Ga");			  g_a         = pin->GetReal("problem","Ga");
  delta_np    = pin->GetReal("problem","Delta");		  delta_np    = pin->GetReal("problem","Delta");
  mcsq        = pin->GetReal("problem","MeCsq");		  mcsq        = pin->GetReal("problem","MeCsq");
  sigma_0     = pin->GetReal("problem","Sigma0");		  sigma_0     = pin->GetReal("problem","Sigma0");
  tau_v       = pin->GetReal("problem","Tau");			  tau_v       = pin->GetReal("problem","Tau");
  tau_epsilon = pin->GetReal("problem","Tau_Eps");		  tau_epsilon = pin->GetReal("problem","Tau_Eps");
  rho_epsilon = pin->GetReal("problem","Rho_Eps");		  rho_epsilon = pin->GetReal("problem","Rho_Eps");
  nthcycle    = pin->GetInteger("problem","ModuloNumber");	  nthcycle    = pin->GetInteger("problem","ModuloNumber");

  // Single NR parameters					  // Single NR parameters
  tgs     = pin->GetReal("problem","Tg_NR");			  tgs     = pin->GetReal("problem","Tg_NR");
  dtg     = pin->GetReal("problem","DeltaTg_NR");		  dtg     = pin->GetReal("problem","DeltaTg_NR");
  dyg     = pin->GetReal("problem","DeltaYeg_NR");		  dyg     = pin->GetReal("problem","DeltaYeg_NR");
  tolsNR  = pin->GetReal("problem","Tolerance_NR");		  tolsNR  = pin->GetReal("problem","Tolerance_NR");
  maxcsNR = pin->GetReal("problem","maxC_NR");			  maxcsNR = pin->GetReal("problem","maxC_NR");
  modsNR  = pin->GetReal("problem","Modifier_NR");		  modsNR  = pin->GetReal("problem","Modifier_NR");

  // Double NR parameters					  // Double NR parameters
  tg      = pin->GetReal("problem","Tg_doubleNR");		  tg      = pin->GetReal("problem","Tg_doubleNR");
  yg      = pin->GetReal("problem","Yeg_doubleNR");		  yg      = pin->GetReal("problem","Yeg_doubleNR");
  dtg     = pin->GetReal("problem","DeltaTg_doubleNR");		  dtg     = pin->GetReal("problem","DeltaTg_doubleNR");
  dyg     = pin->GetReal("problem","DeltaYeg_doubleNR");	  dyg     = pin->GetReal("problem","DeltaYeg_doubleNR");
  toldNR  = pin->GetReal("problem","Tolerance_doubleNR");	  toldNR  = pin->GetReal("problem","Tolerance_doubleNR");
  moddNR  = pin->GetReal("problem","Modifier_doubleNR");	  moddNR  = pin->GetReal("problem","Modifier_doubleNR");
  maxcdNR = pin->GetReal("problem","MaxC_doubleNR");		  maxcdNR = pin->GetReal("problem","MaxC_doubleNR");
  epsdNR  = pin->GetReal("problem","eps_doubleNR");		  epsdNR  = pin->GetReal("problem","eps_doubleNR");

  // final lumonosity/energies					  // final lumonosity/energies
  Real L_nu      = pin->GetReal("problem","L_nu");		  Real L_nu      = pin->GetReal("problem","L_nu");
  Real L_nubar   = pin->GetReal("problem","L_nubar");		  Real L_nubar   = pin->GetReal("problem","L_nubar");
  L_nue          = pin->GetReal("problem","L_nu");		  L_nue          = pin->GetReal("problem","L_nu");
  L_nueb         = pin->GetReal("problem","L_nubar");		  L_nueb         = pin->GetReal("problem","L_nubar");
  Real eps_nu    = pin->GetReal("problem","eps_nu");		  Real eps_nu    = pin->GetReal("problem","eps_nu");
  Real eps_nubar = pin->GetReal("problem","eps_nubar");		  Real eps_nubar = pin->GetReal("problem","eps_nubar");
  eps_nue        = pin->GetReal("problem","eps_nu");		  eps_nue        = pin->GetReal("problem","eps_nu");
  eps_nueb       = pin->GetReal("problem","eps_nubar");		  eps_nueb       = pin->GetReal("problem","eps_nubar");
  Coeff_nu_0     = L_nu * SQR(eps_nu);				  Coeff_nu_0     = L_nu * SQR(eps_nu);
  Coeff_nubar_0  = L_nubar * SQR(eps_nubar);			  Coeff_nubar_0  = L_nubar * SQR(eps_nubar);

  // finial lumonosity/energies					  // finial lumonosity/energies
  L_nu         = pin->GetOrAddReal("problem","L_nu_f",L_nu);	  L_nu         = pin->GetOrAddReal("problem","L_nu_f",L_nu);
  L_nubar      = pin->GetOrAddReal("problem","L_nubar_f",L_nu	  L_nubar      = pin->GetOrAddReal("problem","L_nubar_f",L_nu
  eps_nu       = pin->GetOrAddReal("problem","eps_nu_f",eps_n	  eps_nu       = pin->GetOrAddReal("problem","eps_nu_f",eps_n
  eps_nubar    = pin->GetOrAddReal("problem","eps_nubar_f",ep	  eps_nubar    = pin->GetOrAddReal("problem","eps_nubar_f",ep
  Real coeff   = L_nu * SQR(eps_nu);				  Real coeff   = L_nu * SQR(eps_nu);
  dCoeff_nu    = coeff - Coeff_nu_0;				  dCoeff_nu    = coeff - Coeff_nu_0;
  coeff        = L_nubar * SQR(eps_nubar);			  coeff        = L_nubar * SQR(eps_nubar);
  dCoeff_nubar = coeff - Coeff_nubar_0;				  dCoeff_nubar = coeff - Coeff_nubar_0;
  t_L_0        = pin->GetOrAddReal("problem","l_transition_st	  t_L_0        = pin->GetOrAddReal("problem","l_transition_st
  t_L_1        = pin->GetOrAddReal("problem","l_transition_en	  t_L_1        = pin->GetOrAddReal("problem","l_transition_en
  if (t_L_1 < inf && t_L_1 <= t_L_0) {				  if (t_L_1 < inf && t_L_1 <= t_L_0) {
    std::stringstream msg;					    std::stringstream msg;
    msg << "### FATAL ERROR in Mesh::InitUserMeshData" << std	    msg << "### FATAL ERROR in Mesh::InitUserMeshData" << std
        << "l_transition_end <= l_transition_start" << std::e	        << "l_transition_end <= l_transition_start" << std::e
    ATHENA_ERROR(msg);						    ATHENA_ERROR(msg);
  }								  }
  t_coeff = 0.5 * PI / (t_L_1 - t_L_0);				  t_coeff = 0.5 * PI / (t_L_1 - t_L_0);
  T_floor = pin->GetOrAddReal("hydro", "T_floor", float_eps);	  T_floor = pin->GetOrAddReal("hydro", "T_floor", float_eps);

  // Parse IC choice						  // Parse IC choice
  std::string file;						  std::string file;
  bool has_file = pin->DoesParameterExist("problem", "file");	  bool has_file = pin->DoesParameterExist("problem", "file");
  if (has_file) {						  if (has_file) {
    file = pin->GetString("problem", "file");			    file = pin->GetString("problem", "file");
  }								  }
  bool use_IC_specified = pin->DoesParameterExist("problem", 	  bool use_IC_specified = pin->DoesParameterExist("problem", 
  use_IC_file = pin->GetOrAddBoolean("problem", "use_IC_file"	  use_IC_file = pin->GetOrAddBoolean("problem", "use_IC_file"

  if (use_IC_specified && use_IC_file) {			  if (use_IC_specified && use_IC_file) {
    if (!has_file) {						    if (!has_file) {
      std::stringstream msg;					      std::stringstream msg;
      msg << "### FATAL ERROR in Mesh::InitUserMeshData" << s	      msg << "### FATAL ERROR in Mesh::InitUserMeshData" << s
          << "No IC file specified in input file." << std::en	          << "No IC file specified in input file." << std::en
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
    }								    }
    if (!exists(file)) {					    if (!exists(file)) {
      std::stringstream msg;					      std::stringstream msg;
      msg << "### FATAL ERROR in Mesh::InitUserMeshData" << s	      msg << "### FATAL ERROR in Mesh::InitUserMeshData" << s
          << "Specified IC file " << file << "does not exits.	          << "Specified IC file " << file << "does not exits.
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
    }								    }
  }								  }

  if (has_file) {						  if (has_file) {
    if (!exists(file)) {					    if (!exists(file)) {
      use_IC_file = false;					      use_IC_file = false;
      if (Globals::my_rank == 0) {				      if (Globals::my_rank == 0) {
        std::cout << "Unable to locate IC file " << file << "	        std::cout << "Unable to locate IC file " << file << "
                  << std::endl;					                  << std::endl;
      }								      }
    }								    }
  }								  }

  // Read ICs from data file					  // Read ICs from data file
  if (use_IC_file) {						  if (use_IC_file) {
    rows        = pin->GetInteger("problem", "rows");		    rows        = pin->GetInteger("problem", "rows");
    int cols    = pin->GetInteger("problem", "cols");		    int cols    = pin->GetInteger("problem", "cols");
    int col_rho = pin->GetInteger("problem", "col_rho");	    int col_rho = pin->GetInteger("problem", "col_rho");
    int col_v   = pin->GetInteger("problem", "col_v");		    int col_v   = pin->GetInteger("problem", "col_v");
    int col_T   = pin->GetInteger("problem", "col_T");		    int col_T   = pin->GetInteger("problem", "col_T");
    int col_Ye  = pin->GetInteger("problem", "col_Ye");		    int col_Ye  = pin->GetInteger("problem", "col_Ye");

    // Prepare arrays to hold profile				    // Prepare arrays to hold profile
    AllocateRealUserMeshDataField(11);				    AllocateRealUserMeshDataField(11);

    ruser_mesh_data[0].NewAthenaArray(rows);			    ruser_mesh_data[0].NewAthenaArray(rows);
    ruser_mesh_data[1].NewAthenaArray(rows);			    ruser_mesh_data[1].NewAthenaArray(rows);
    ruser_mesh_data[2].NewAthenaArray(rows);			    ruser_mesh_data[2].NewAthenaArray(rows);
    ruser_mesh_data[3].NewAthenaArray(rows);			    ruser_mesh_data[3].NewAthenaArray(rows);
    ruser_mesh_data[4].NewAthenaArray(rows);			    ruser_mesh_data[4].NewAthenaArray(rows);
    ruser_mesh_data[5].NewAthenaArray(rows);			    ruser_mesh_data[5].NewAthenaArray(rows);
    ruser_mesh_data[6].NewAthenaArray(rows);			    ruser_mesh_data[6].NewAthenaArray(rows);
    ruser_mesh_data[7].NewAthenaArray(rows);			    ruser_mesh_data[7].NewAthenaArray(rows);
    ruser_mesh_data[8].NewAthenaArray(rows);			    ruser_mesh_data[8].NewAthenaArray(rows);
    ruser_mesh_data[9].NewAthenaArray(rows);			    ruser_mesh_data[9].NewAthenaArray(rows);
    AthenaArray<Real>& r_in{ruser_mesh_data[0]};		    AthenaArray<Real>& r_in{ruser_mesh_data[0]};
    AthenaArray<Real>& rho_in{ruser_mesh_data[1]};		    AthenaArray<Real>& rho_in{ruser_mesh_data[1]};
    AthenaArray<Real>& v_in{ruser_mesh_data[2]};		    AthenaArray<Real>& v_in{ruser_mesh_data[2]};
    AthenaArray<Real>& T_in{ruser_mesh_data[3]};		    AthenaArray<Real>& T_in{ruser_mesh_data[3]};
    AthenaArray<Real>& Ye_in{ruser_mesh_data[4]};		    AthenaArray<Real>& Ye_in{ruser_mesh_data[4]};

    // Data structure for calculating optical depth [IS THIS 	    // Data structure for calculating optical depth [IS THIS 
    AthenaArray<Real>& lsum{ruser_mesh_data[5]};		    AthenaArray<Real>& lsum{ruser_mesh_data[5]};
    AthenaArray<Real>& oldrho{ruser_mesh_data[6]};		    AthenaArray<Real>& oldrho{ruser_mesh_data[6]};
    AthenaArray<Real>& Teq{ruser_mesh_data[7]};			    AthenaArray<Real>& Teq{ruser_mesh_data[7]};
    AthenaArray<Real>& PGZ{ruser_mesh_data[8]};			    AthenaArray<Real>& PGZ{ruser_mesh_data[8]};

    // Data stucture for tracking cycle number			    // Data stucture for tracking cycle number
    AllocateIntUserMeshDataField(1);				    AllocateIntUserMeshDataField(1);
    iuser_mesh_data[0].NewAthenaArray(rows);			    iuser_mesh_data[0].NewAthenaArray(rows);
    AthenaArray<int>& counter{iuser_mesh_data[0]};		    AthenaArray<int>& counter{iuser_mesh_data[0]};

    if (Globals::my_rank == 0)					    if (Globals::my_rank == 0)
      std::cout<< "Using IC file: " << file << "\n";		      std::cout<< "Using IC file: " << file << "\n";

    std::string line;						    std::string line;
    std::ifstream stream;					    std::ifstream stream;
    stream.open(file);						    stream.open(file);
    Real s_vals[cols];						    Real s_vals[cols];

    for (int n = 0; n < rows; ++n) {				    for (int n = 0; n < rows; ++n) {
      std::getline(stream, line);				      std::getline(stream, line);
      std::string word;						      std::string word;
      std::stringstream iss(line);				      std::stringstream iss(line);
      int m=0;							      int m=0;
      while (iss >> word) {					      while (iss >> word) {
        s_vals[m]=std::stof(word);				        s_vals[m]=std::stof(word);
        m=m+1;							        m=m+1;
      }								      }
      r_in(n)   = s_vals[0];					      r_in(n)   = s_vals[0];
      rho_in(n) = s_vals[col_rho+1];				      rho_in(n) = s_vals[col_rho+1];
      v_in(n)   = s_vals[col_v+1];				      v_in(n)   = s_vals[col_v+1];
      T_in(n)   = s_vals[col_T+1];				      T_in(n)   = s_vals[col_T+1];
      Ye_in(n)  = s_vals[col_Ye+1];				      Ye_in(n)  = s_vals[col_Ye+1];
    }								    }
  }								  }
  return;							  return;
}								}

void MeshBlock::InitUserMeshBlockData(ParameterInput *pin) {	void MeshBlock::InitUserMeshBlockData(ParameterInput *pin) {

  if (COMP_DT) {						  if (COMP_DT) {
      int i = 0;						      int i = 0;

      IDT1 = i;							      IDT1 = i;
      IDT2 = i + 1;						      IDT2 = i + 1;
      IDT3 = i + 2;						      IDT3 = i + 2;
      IDT4 = i + 3;						      IDT4 = i + 3;
      IDT5 = i + 4;						      IDT5 = i + 4;
      IDT6 = i + 5;						      IDT6 = i + 5;
      IDT7 = i + 6;						      IDT7 = i + 6;
      IDT8 = i + 7;						      IDT8 = i + 7;
      IDT9 = i + 8;						      IDT9 = i + 8;
      IDT10 = i + 9;						      IDT10 = i + 9;
      IDT11 = i + 10;						      IDT11 = i + 10;
      IDT12 = i + 11;						      IDT12 = i + 11;
      i += 12;							      i += 12;

      AllocateUserOutputVariables(i);				      AllocateUserOutputVariables(i);

      SetUserOutputVariableName(IDT1, "dt1");			      SetUserOutputVariableName(IDT1, "dt1");
      SetUserOutputVariableName(IDT2, "dt2");			      SetUserOutputVariableName(IDT2, "dt2");
      SetUserOutputVariableName(IDT3, "dt3");			      SetUserOutputVariableName(IDT3, "dt3");
      SetUserOutputVariableName(IDT4, "x1flux");		      SetUserOutputVariableName(IDT4, "x1flux");
      SetUserOutputVariableName(IDT5, "dflx_vol");		      SetUserOutputVariableName(IDT5, "dflx_vol");
      SetUserOutputVariableName(IDT6, "coord_src1");		      SetUserOutputVariableName(IDT6, "coord_src1");
      SetUserOutputVariableName(IDT7, "extra1");		      SetUserOutputVariableName(IDT7, "extra1");
      SetUserOutputVariableName(IDT8, "extra2");		      SetUserOutputVariableName(IDT8, "extra2");
      SetUserOutputVariableName(IDT9, "extra3");		      SetUserOutputVariableName(IDT9, "extra3");
      SetUserOutputVariableName(IDT10, "extra4");		      SetUserOutputVariableName(IDT10, "extra4");
      SetUserOutputVariableName(IDT11, "extra5");		      SetUserOutputVariableName(IDT11, "extra5");
      SetUserOutputVariableName(IDT12, "extra6");		      SetUserOutputVariableName(IDT12, "extra6");

  }								  }
}								}

//-----------------------------------------------------------	//-----------------------------------------------------------
//! \fn void MeshBlock::ProblemGenerator(ParameterInput *pin)	//! \fn void MeshBlock::ProblemGenerator(ParameterInput *pin)
//  \brief Problem Generator for the Parker wind		//  \brief Problem Generator for the Parker wind

void MeshBlock::ProblemGenerator(ParameterInput *pin) {		void MeshBlock::ProblemGenerator(ParameterInput *pin) {
  if (use_IC_file) {						  if (use_IC_file) {
    // define references for MeshBlock::ProblemGenerator	    // define references for MeshBlock::ProblemGenerator
    AthenaArray<Real>& r_in{pmy_mesh->ruser_mesh_data[0]};	    AthenaArray<Real>& r_in{pmy_mesh->ruser_mesh_data[0]};
    AthenaArray<Real>& rho_in{pmy_mesh->ruser_mesh_data[1]};	    AthenaArray<Real>& rho_in{pmy_mesh->ruser_mesh_data[1]};
    AthenaArray<Real>& v_in{pmy_mesh->ruser_mesh_data[2]};	    AthenaArray<Real>& v_in{pmy_mesh->ruser_mesh_data[2]};
    AthenaArray<Real>& T_in{pmy_mesh->ruser_mesh_data[3]};	    AthenaArray<Real>& T_in{pmy_mesh->ruser_mesh_data[3]};
    AthenaArray<Real>& Ye_in{pmy_mesh->ruser_mesh_data[4]};	    AthenaArray<Real>& Ye_in{pmy_mesh->ruser_mesh_data[4]};

    for (int k=ks; k<=ke; k++) {				    for (int k=ks; k<=ke; k++) {
      // Real phi = pcoord->x3v(k);				      // Real phi = pcoord->x3v(k);
      for (int j=js; j<=je; j++) {				      for (int j=js; j<=je; j++) {
        Real theta = pcoord->x2v(j);				        Real theta = pcoord->x2v(j);
        for (int i=is; i<=ie; i++) {				        for (int i=is; i<=ie; i++) {
          Real r  = pcoord->x1v(i);				          Real r  = pcoord->x1v(i);
          Real r0 = 5e6;					          Real r0 = 5e6;
          Real mn = 1.6749286e-24;                // baryon m	          Real mn = 1.6749286e-24;                // baryon m
          Real rho, v, temp, ye;				          Real rho, v, temp, ye;

          int index=0;						          int index=0;
          Real min = 1e15;					          Real min = 1e15;
          Real diff;						          Real diff;

          for (int f=0; f<rows; f++) {				          for (int f=0; f<rows; f++) {
            diff = r-r_in(f);					            diff = r-r_in(f);
            if(diff>=0.0) {					            if(diff>=0.0) {
              if(diff<min) {					              if(diff<min) {
                min   = diff;					                min   = diff;
                index = f;					                index = f;
              }							              }
            }							            }
          }							          }
          //linear interpolation when r values in ICs and sim	          //linear interpolation when r values in ICs and sim
          if(r<2.1e6 and rho_0>1.5e12) {			          if(r<2.1e6 and rho_0>1.5e12) {
            Real qp = std::pow(r_0/r,20.0);			            Real qp = std::pow(r_0/r,20.0);
            rho     = rho_0*qp;					            rho     = rho_0*qp;
            // Real mdot= 4.0*3.14*r*r*rho_in(index)*v_in(ind	            // Real mdot= 4.0*3.14*r*r*rho_in(index)*v_in(ind
            v = (4.34e-4)*2e33/(4.0*3.14*r*r*rho);		            v = (4.34e-4)*2e33/(4.0*3.14*r*r*rho);
          }							          }
          else {						          else {
            rho = rho_in(index)+(r-r_in(index))*(rho_in(index	            rho = rho_in(index)+(r-r_in(index))*(rho_in(index
                      /(r_in(index+1)-r_in(index));		                      /(r_in(index+1)-r_in(index));
            v   = v_in(index)+(r-r_in(index))*(v_in(index+1)-	            v   = v_in(index)+(r-r_in(index))*(v_in(index+1)-
                    /(r_in(index+1)-r_in(index));		                    /(r_in(index+1)-r_in(index));
          }							          }

          temp = T_in(index)+(r-r_in(index))*(T_in(index+1)-T	          temp = T_in(index)+(r-r_in(index))*(T_in(index+1)-T
                    /(r_in(index+1)-r_in(index));		                    /(r_in(index+1)-r_in(index));
          ye   = Ye_in(index)+(r-r_in(index))*(Ye_in(index+1)	          ye   = Ye_in(index)+(r-r_in(index))*(Ye_in(index+1)
                    /(r_in(index+1)-r_in(index));		                    /(r_in(index+1)-r_in(index));

          phydro->u(IDN,k,j,i)        = rho;			          phydro->u(IDN,k,j,i)        = rho;
          phydro->u(IM1,k,j,i)        = v * rho;		          phydro->u(IM1,k,j,i)        = v * rho;
          phydro->u(IM2,k,j,i)        = 0.0;			          phydro->u(IM2,k,j,i)        = 0.0;
          phydro->u(IM3,k,j,i)        = 0.0;			          phydro->u(IM3,k,j,i)        = 0.0;
          pscalars->s(ye_index,k,j,i) = ye * rho;		          pscalars->s(ye_index,k,j,i) = ye * rho;
          pscalars->s(t_index,k,j,i)  = temp * rho;		          pscalars->s(t_index,k,j,i)  = temp * rho;
          pscalars->r(ye_index,k,j,i) = ye;			          pscalars->r(ye_index,k,j,i) = ye;
          pscalars->r(t_index,k,j,i)  = temp;			          pscalars->r(t_index,k,j,i)  = temp;
          edens                       = &pscalars->s(ye_index	          edens                       = &pscalars->s(ye_index
          efrac                       = &pscalars->r(ye_index	          efrac                       = &pscalars->r(ye_index
          Real r_scalar[nscalar_size];				          Real r_scalar[nscalar_size];
          Real s_scalar[nscalar_size];				          Real s_scalar[nscalar_size];
          for (int ns=0; ns<nscalar_size; ns++) {		          for (int ns=0; ns<nscalar_size; ns++) {
            r_scalar[ns] = pscalars->r(ns,k,j,i);		            r_scalar[ns] = pscalars->r(ns,k,j,i);
            s_scalar[ns] = pscalars->s(ns,k,j,i);		            s_scalar[ns] = pscalars->s(ns,k,j,i);
          }							          }

          if(std::isnan(pscalars->r(ye_index,k,j,i)) || pscal	          if(std::isnan(pscalars->r(ye_index,k,j,i)) || pscal
            std::cout << "(ProblemGenerator) Ye is nan or sup	            std::cout << "(ProblemGenerator) Ye is nan or sup
            std::cout << "Ye  = " << pscalars->r(ye_index,k,j	            std::cout << "Ye  = " << pscalars->r(ye_index,k,j
            std::cout << "rho = " << phydro->u(IDN,k,j,i) << 	            std::cout << "rho = " << phydro->u(IDN,k,j,i) << 
            std::cout << "T   = " << temp << " K" << std::end	            std::cout << "T   = " << temp << " K" << std::end
          }							          }
          if(std::isnan(temp)) {				          if(std::isnan(temp)) {
            std::cout << "(ProblemGenerator) temp is nan (1):	            std::cout << "(ProblemGenerator) temp is nan (1):
            std::cout << "Ye  = " << pscalars->r(ye_index,k,j	            std::cout << "Ye  = " << pscalars->r(ye_index,k,j
            std::cout << "rho = " << phydro->u(IDN,k,j,i) << 	            std::cout << "rho = " << phydro->u(IDN,k,j,i) << 
            std::cout << "T   = " << temp << " K" << std::end	            std::cout << "T   = " << temp << " K" << std::end
          }							          }
          if(std::isnan(phydro->u(IDN,k,j,i))) {		          if(std::isnan(phydro->u(IDN,k,j,i))) {
            std::cout << "(ProblemGenerator) rho is nan (2):"	            std::cout << "(ProblemGenerator) rho is nan (2):"
            std::cout << "Ye  = " << pscalars->r(ye_index,k,j	            std::cout << "Ye  = " << pscalars->r(ye_index,k,j
            std::cout << "rho = " << phydro->u(IDN,k,j,i) << 	            std::cout << "rho = " << phydro->u(IDN,k,j,i) << 
            std::cout << "T   = " << temp << " K" << std::end	            std::cout << "T   = " << temp << " K" << std::end
          }							          }
          if (NON_BAROTROPIC_EOS) {				          if (NON_BAROTROPIC_EOS) {
            if (GENERAL_EOS) {					            if (GENERAL_EOS) {
              Real pressure        = peos->PresFromRhoT(rho, 	              Real pressure        = peos->PresFromRhoT(rho, 
              phydro->u(IEN,k,j,i) = peos->EgasFromRhoP(rho, 	              phydro->u(IEN,k,j,i) = peos->EgasFromRhoP(rho, 
           //   if(i==ie-1) {					           //   if(i==ie-1) {
           //     std::cout <<"(ProblemGenerator at i=ie-i): 	           //     std::cout <<"(ProblemGenerator at i=ie-i): 
           //     std::cout << "rho    = " << phydro->u(IDN,k	           //     std::cout << "rho    = " << phydro->u(IDN,k
           //     std::cout << "Ye     = " << pscalars->r(ye_	           //     std::cout << "Ye     = " << pscalars->r(ye_
           //     std::cout << "T      = " << temp << " K" <<	           //     std::cout << "T      = " << temp << " K" <<
           //     std::cout << "P      = " << pressure << " e	           //     std::cout << "P      = " << pressure << " e
           //     std::cout << "u(IPR) = " << phydro->u(IPR,k	           //     std::cout << "u(IPR) = " << phydro->u(IPR,k
           //     std::cout << " " << std::endl;		           //     std::cout << " " << std::endl;
           //   }						           //   }
           //   if(i==ie) {					           //   if(i==ie) {
           //     std::cout <<"(ProblemGenerator at i=ie): r 	           //     std::cout <<"(ProblemGenerator at i=ie): r 
           //     std::cout << "rho    = " << phydro->u(IDN,k	           //     std::cout << "rho    = " << phydro->u(IDN,k
           //     std::cout << "Ye     = " << pscalars->r(ye_	           //     std::cout << "Ye     = " << pscalars->r(ye_
           //     std::cout << "T      = " << temp << " K" <<	           //     std::cout << "T      = " << temp << " K" <<
           //     std::cout << "P      = " << pressure << " e	           //     std::cout << "P      = " << pressure << " e
           //     std::cout << "u(IPR) = " << phydro->u(IPR,k	           //     std::cout << "u(IPR) = " << phydro->u(IPR,k
           //     std::cout << " " << std::endl;		           //     std::cout << " " << std::endl;
           //   }						           //   }
            }							            }
            phydro->u(IEN,k,j,i) += 0.5 * (SQR(phydro->u(IM1,	            phydro->u(IEN,k,j,i) += 0.5 * (SQR(phydro->u(IM1,
                                        +  SQR(phydro->u(IM3,	                                        +  SQR(phydro->u(IM3,

          }							          }
        }							        }
      }								      }
    }								    }
  }								  }

  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    // if root processor and zeroth block			    // if root processor and zeroth block
    if ((Globals::my_rank == 0) && (lid == 0)){			    if ((Globals::my_rank == 0) && (lid == 0)){
      std::cout<<"YES ENTER B field\n";				      std::cout<<"YES ENTER B field\n";
    }								    }
    AthenaArray<Real> a1,a2,a3;					    AthenaArray<Real> a1,a2,a3;
    int nx1 = (ie-is)+1 + 2*(NGHOST);				    int nx1 = (ie-is)+1 + 2*(NGHOST);
    int nx2 = (je-js)+1 + 2*(NGHOST);				    int nx2 = (je-js)+1 + 2*(NGHOST);
    int nx3 = (ke-ks)+1 + 2*(NGHOST);				    int nx3 = (ke-ks)+1 + 2*(NGHOST);
    a1.NewAthenaArray(nx3,nx2,nx1);				    a1.NewAthenaArray(nx3,nx2,nx1);
    a2.NewAthenaArray(nx3,nx2,nx1);				    a2.NewAthenaArray(nx3,nx2,nx1);
    a3.NewAthenaArray(nx3,nx2,nx1);				    a3.NewAthenaArray(nx3,nx2,nx1);

    for (int k=ks; k<=ke+1; k++) {				    for (int k=ks; k<=ke+1; k++) {
      for (int j=js; j<=je+1; j++) {				      for (int j=js; j<=je+1; j++) {
        for (int i=is; i<=ie+1; i++) {				        for (int i=is; i<=ie+1; i++) {
          a1(k,j,i) = A1(pcoord->x1v(i), pcoord->x2f(j), pcoo	          a1(k,j,i) = A1(pcoord->x1v(i), pcoord->x2f(j), pcoo
          a2(k,j,i) = A2(pcoord->x1f(i), pcoord->x2v(j), pcoo	          a2(k,j,i) = A2(pcoord->x1f(i), pcoord->x2v(j), pcoo
          a3(k,j,i) = A3(pcoord->x1f(i), pcoord->x2f(j), pcoo	          a3(k,j,i) = A3(pcoord->x1f(i), pcoord->x2f(j), pcoo
        }							        }
      }								      }
    }								    }

    // Initialize interface fields				    // Initialize interface fields
    AthenaArray<Real> area,len,len_p1;				    AthenaArray<Real> area,len,len_p1;
    area.NewAthenaArray(nx1);					    area.NewAthenaArray(nx1);
    len.NewAthenaArray(nx1);					    len.NewAthenaArray(nx1);
    len_p1.NewAthenaArray(nx1);					    len_p1.NewAthenaArray(nx1);

    // for 1,2,3-D						    // for 1,2,3-D
    int jl=js; int ju=je+1;					    int jl=js; int ju=je+1;
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      // reset loop limits for polar boundary			      // reset loop limits for polar boundary

      if ((pbval->block_bcs[BoundaryFace::inner_x2] == Bounda	      if ((pbval->block_bcs[BoundaryFace::inner_x2] == Bounda
        (pbval->block_bcs[BoundaryFace::inner_x2] == Boundary	        (pbval->block_bcs[BoundaryFace::inner_x2] == Boundary
        jl=js+1;						        jl=js+1;
      if ((pbval->block_bcs[BoundaryFace::outer_x2] == Bounda	      if ((pbval->block_bcs[BoundaryFace::outer_x2] == Bounda
        (pbval->block_bcs[BoundaryFace::outer_x2] == Boundary	        (pbval->block_bcs[BoundaryFace::outer_x2] == Boundary
        ju=je;							        ju=je;
      for (int j=jl; j<=ju; ++j) {				      for (int j=jl; j<=ju; ++j) {
        pcoord->Face2Area(k,j,is,ie,area);			        pcoord->Face2Area(k,j,is,ie,area);
        pcoord->Edge3Length(k,j,is,ie+1,len);			        pcoord->Edge3Length(k,j,is,ie+1,len);
        for (int i=is; i<=ie; ++i) {				        for (int i=is; i<=ie; ++i) {
          pfield->b.x2f(k,j,i) = -1.0*(len(i+1)*a3(k,j,i+1) -	          pfield->b.x2f(k,j,i) = -1.0*(len(i+1)*a3(k,j,i+1) -
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
        pcoord->Face3Area(k,j,is,ie,area);			        pcoord->Face3Area(k,j,is,ie,area);
        pcoord->Edge2Length(k,j,is,ie+1,len);			        pcoord->Edge2Length(k,j,is,ie+1,len);
        for (int i=is; i<=ie; ++i) {				        for (int i=is; i<=ie; ++i) {
          pfield->b.x3f(k,j,i) = (len(i+1)*a2(k,j,i+1) - len(	          pfield->b.x3f(k,j,i) = (len(i+1)*a2(k,j,i+1) - len(
        }							        }
      }								      }
    }								    }

    // for 2D and 3D						    // for 2D and 3D
    if (block_size.nx2 > 1) {					    if (block_size.nx2 > 1) {
      for (int k=ks; k<=ke; ++k) {				      for (int k=ks; k<=ke; ++k) {
        for (int j=js; j<=je; ++j) {				        for (int j=js; j<=je; ++j) {
          pcoord->Face1Area(k,j,is,ie+1,area);			          pcoord->Face1Area(k,j,is,ie+1,area);
          pcoord->Edge3Length(k,j  ,is,ie+1,len);		          pcoord->Edge3Length(k,j  ,is,ie+1,len);
          pcoord->Edge3Length(k,j+1,is,ie+1,len_p1);		          pcoord->Edge3Length(k,j+1,is,ie+1,len_p1);
          for (int i=is; i<=ie+1; ++i) {			          for (int i=is; i<=ie+1; ++i) {
            pfield->b.x1f(k,j,i) = (len_p1(i)*a3(k,j+1,i) - l	            pfield->b.x1f(k,j,i) = (len_p1(i)*a3(k,j+1,i) - l
          }							          }
        }							        }
      }								      }
      for (int k=ks; k<=ke+1; ++k) {				      for (int k=ks; k<=ke+1; ++k) {
        for (int j=js; j<=je; ++j) {				        for (int j=js; j<=je; ++j) {
          pcoord->Face3Area(k,j,is,ie,area);			          pcoord->Face3Area(k,j,is,ie,area);
          pcoord->Edge1Length(k,j  ,is,ie,len);			          pcoord->Edge1Length(k,j  ,is,ie,len);
          pcoord->Edge1Length(k,j+1,is,ie,len_p1);		          pcoord->Edge1Length(k,j+1,is,ie,len_p1);
          for (int i=is; i<=ie; ++i) {				          for (int i=is; i<=ie; ++i) {
            pfield->b.x3f(k,j,i) -= (len_p1(i)*a1(k,j+1,i) - 	            pfield->b.x3f(k,j,i) -= (len_p1(i)*a1(k,j+1,i) - 
          }							          }
        }							        }
      }								      }
    }								    }
    // for 3D only						    // for 3D only
    if (block_size.nx3 > 1) {					    if (block_size.nx3 > 1) {
      for (int k=ks; k<=ke; ++k) {				      for (int k=ks; k<=ke; ++k) {
        for (int j=js; j<=je; ++j) {				        for (int j=js; j<=je; ++j) {
          pcoord->Face1Area(k,j,is,ie+1,area);			          pcoord->Face1Area(k,j,is,ie+1,area);
          pcoord->Edge2Length(k  ,j,is,ie+1,len);		          pcoord->Edge2Length(k  ,j,is,ie+1,len);
          pcoord->Edge2Length(k+1,j,is,ie+1,len_p1);		          pcoord->Edge2Length(k+1,j,is,ie+1,len_p1);
          for (int i=is; i<=ie+1; ++i) {			          for (int i=is; i<=ie+1; ++i) {
            pfield->b.x1f(k,j,i) -= (len_p1(i)*a2(k+1,j,i) - 	            pfield->b.x1f(k,j,i) -= (len_p1(i)*a2(k+1,j,i) - 
          }							          }
        }							        }
      }								      }
      for (int k=ks; k<=ke; ++k) {				      for (int k=ks; k<=ke; ++k) {
        // reset loop limits for polar boundary			        // reset loop limits for polar boundary
        int jl=js; int ju=je+1;					        int jl=js; int ju=je+1;
        if ((pbval->block_bcs[BoundaryFace::inner_x2] == Boun	        if ((pbval->block_bcs[BoundaryFace::inner_x2] == Boun
          (pbval->block_bcs[BoundaryFace::inner_x2] == Bounda	          (pbval->block_bcs[BoundaryFace::inner_x2] == Bounda
          jl=js+1;						          jl=js+1;
        if ((pbval->block_bcs[BoundaryFace::outer_x2] == Boun	        if ((pbval->block_bcs[BoundaryFace::outer_x2] == Boun
          (pbval->block_bcs[BoundaryFace::outer_x2] == Bounda	          (pbval->block_bcs[BoundaryFace::outer_x2] == Bounda
          ju=je;						          ju=je;
        for (int j=jl; j<=ju; ++j) {				        for (int j=jl; j<=ju; ++j) {
          pcoord->Face2Area(k,j,is,ie,area);			          pcoord->Face2Area(k,j,is,ie,area);
          pcoord->Edge1Length(k  ,j,is,ie,len);			          pcoord->Edge1Length(k  ,j,is,ie,len);
          pcoord->Edge1Length(k+1,j,is,ie,len_p1);		          pcoord->Edge1Length(k+1,j,is,ie,len_p1);
          for (int i=is; i<=ie; ++i) {				          for (int i=is; i<=ie; ++i) {
            pfield->b.x2f(k,j,i) += (len_p1(i)*a1(k+1,j,i) - 	            pfield->b.x2f(k,j,i) += (len_p1(i)*a1(k+1,j,i) - 
          }							          }
        }							        }
      }								      }
    }								    }
    // Calculate cell-centered magnetic field			    // Calculate cell-centered magnetic field
    AthenaArray<Real> bb;					    AthenaArray<Real> bb;
    bb.NewAthenaArray(3, ke+1, je+1, ie+NGHOST+1);		    bb.NewAthenaArray(3, ke+1, je+1, ie+NGHOST+1);
    pfield->CalculateCellCenteredField(pfield->b, bb, pcoord,	    pfield->CalculateCellCenteredField(pfield->b, bb, pcoord,
                                       je, ks, ke);		                                       je, ks, ke);

    for (int k=ks; k<=ke; k++) {				    for (int k=ks; k<=ke; k++) {
      for (int j=js; j<=je; j++) {				      for (int j=js; j<=je; j++) {
        for (int i=is; i<=ie; i++) {				        for (int i=is; i<=ie; i++) {
          Real& bcc1 = bb(IB1,k,j,i);				          Real& bcc1 = bb(IB1,k,j,i);
          Real& bcc2 = bb(IB2,k,j,i);				          Real& bcc2 = bb(IB2,k,j,i);
          Real& bcc3 = bb(IB3,k,j,i);				          Real& bcc3 = bb(IB3,k,j,i);

          phydro->u(IEN,k,j,i) += 0.5*(SQR(bcc1)+SQR(bcc2)+SQ	          phydro->u(IEN,k,j,i) += 0.5*(SQR(bcc1)+SQR(bcc2)+SQ
         }							         }
      }								      }
    }								    }
    a1.DeleteAthenaArray();					    a1.DeleteAthenaArray();
    a2.DeleteAthenaArray();					    a2.DeleteAthenaArray();
    a3.DeleteAthenaArray();					    a3.DeleteAthenaArray();
    area.DeleteAthenaArray();					    area.DeleteAthenaArray();
    len.DeleteAthenaArray();					    len.DeleteAthenaArray();
    len_p1.DeleteAthenaArray();					    len_p1.DeleteAthenaArray();
    bb.DeleteAthenaArray();					    bb.DeleteAthenaArray();
  } // end if MAGNETIC_FIELDS_ENABLED				  } // end if MAGNETIC_FIELDS_ENABLED
}								}

// Source Terms							// Source Terms
void heat_cool(MeshBlock *pmb, const Real time, const Real dt	void heat_cool(MeshBlock *pmb, const Real time, const Real dt
               const AthenaArray<Real> &prim, const AthenaArr	               const AthenaArray<Real> &prim, const AthenaArr
               const AthenaArray<Real> &bcc, AthenaArray<Real	               const AthenaArray<Real> &bcc, AthenaArray<Real
               AthenaArray<Real> &cons_scalar) {		               AthenaArray<Real> &cons_scalar) {

  for (int k=pmb->ks; k<=pmb->ke; ++k) {			  for (int k=pmb->ks; k<=pmb->ke; ++k) {
    for (int j=pmb->js; j<=pmb->je; ++j) {			    for (int j=pmb->js; j<=pmb->je; ++j) {
      for (int i=pmb->is; i<=pmb->ie; ++i) {			      for (int i=pmb->is; i<=pmb->ie; ++i) {
        Real erg2MeV  = 6.24151e5;                    // Erg 	        Real erg2MeV  = 6.24151e5;                    // Erg 
        Real r        = pmb->pcoord->x1v(i);          // Radi	        Real r        = pmb->pcoord->x1v(i);          // Radi
        Real p        = prim(IPR,k,j,i);              // Pres	        Real p        = prim(IPR,k,j,i);              // Pres
        Real rho      = prim(IDN,k,j,i);              // Dens	        Real rho      = prim(IDN,k,j,i);              // Dens
        Real kbol_MeV = 8.61733326*std::pow(10,-11);  // Bolt	        Real kbol_MeV = 8.61733326*std::pow(10,-11);  // Bolt
        Real Ye_i     = prim_scalar(ye_index,k,j,i);  // Elec	        Real Ye_i     = prim_scalar(ye_index,k,j,i);  // Elec
        efrac         = &Ye_i;                        // Elec	        efrac         = &Ye_i;                        // Elec

        Real r_scalar[nscalar_size];				        Real r_scalar[nscalar_size];
        Real s_scalar[nscalar_size];				        Real s_scalar[nscalar_size];
        for (int ns=0; ns<nscalar_size; ns++) {			        for (int ns=0; ns<nscalar_size; ns++) {
          r_scalar[ns] = prim_scalar(ns,k,j,i);			          r_scalar[ns] = prim_scalar(ns,k,j,i);
          s_scalar[ns] = cons_scalar(ns,k,j,i);			          s_scalar[ns] = cons_scalar(ns,k,j,i);
        }							        }


        // Calculate source terms				        // Calculate source terms
//        Real temp   = pmb->peos->TFromRhoP(rho, p, efrac) *	//        Real temp   = pmb->peos->TFromRhoP(rho, p, efrac) *
//        Real temp   = pmb->peos->TFromRhoP(rho, p, r_scalar	//        Real temp   = pmb->peos->TFromRhoP(rho, p, r_scalar
        Real temp = prim_scalar(t_index,k,j,i) * kbol_MeV; //	        Real temp = prim_scalar(t_index,k,j,i) * kbol_MeV; //
//        std::cout << "(heat_cool) temp = " << temp << " MeV	//        std::cout << "(heat_cool) temp = " << temp << " MeV
//        std::cout << "(heat_cool) r    = " << r << " cm" <<	//        std::cout << "(heat_cool) r    = " << r << " cm" <<
//        std::cout << " " << std::endl;			//        std::cout << " " << std::endl;
        if(std::isnan(Ye_i)) {					        if(std::isnan(Ye_i)) {
          std::cout << "(heat_cool) NANS (0) (Ye_i)" << std::	          std::cout << "(heat_cool) NANS (0) (Ye_i)" << std::
          std::cout << "Ye_i  = " << Ye_i << std::endl;		          std::cout << "Ye_i  = " << Ye_i << std::endl;
          std::cout << "p     = " << p    << "erg/cm^3" <<std	          std::cout << "p     = " << p    << "erg/cm^3" <<std
          std::cout << "temp  = " << temp << "MeV" <<std::end	          std::cout << "temp  = " << temp << "MeV" <<std::end
          std::cout << "rho   = " << rho  << "g/cm^3" <<std::	          std::cout << "rho   = " << rho  << "g/cm^3" <<std::
          std::cout << " " << std::endl;			          std::cout << " " << std::endl;
        }							        }
        if(std::isnan(temp)) {					        if(std::isnan(temp)) {
          std::cout << "(heat_cool) NANS (1) (temp)" << std::	          std::cout << "(heat_cool) NANS (1) (temp)" << std::
          std::cout << "Ye_i  = " << Ye_i << std::endl;		          std::cout << "Ye_i  = " << Ye_i << std::endl;
          std::cout << "p     = " << p    << "erg/cm^3" <<std	          std::cout << "p     = " << p    << "erg/cm^3" <<std
          std::cout << "temp  = " << temp << "MeV" <<std::end	          std::cout << "temp  = " << temp << "MeV" <<std::end
          std::cout << "rho   = " << rho  << "g/cm^3" <<std::	          std::cout << "rho   = " << rho  << "g/cm^3" <<std::
          std::cout << " " << std::endl;			          std::cout << " " << std::endl;
        }							        }
        Real X_n    = 1.0; //Xn(rho, temp);			        Real X_n    = 1.0; //Xn(rho, temp);
        if (r>5.0e6) {						        if (r>5.0e6) {
//        if (temp < 1.0) {					//        if (temp < 1.0) {
          X_n = X_nucleon(rho, temp);				          X_n = X_nucleon(rho, temp);
        }							        }
        Real x       = std::sqrt(1.0-(r_0*r_0)/(r*r));		        Real x       = std::sqrt(1.0-(r_0*r_0)/(r*r));
        Real ExpSupp = std::exp(-1.0 * rho / rho_0);		        Real ExpSupp = std::exp(-1.0 * rho / rho_0);

//        Real vdYedr = 0.0; //std::min(1.0, X_n) * (YeSource	//        Real vdYedr = 0.0; //std::min(1.0, X_n) * (YeSource
//        Real vdYedr = std::min(1.0, X_n) * (YeSource_QW_Mod	//        Real vdYedr = std::min(1.0, X_n) * (YeSource_QW_Mod
        Real vdYedr = ExpSupp * std::min(1.0,X_n) * YeTejas(t	        Real vdYedr = ExpSupp * std::min(1.0,X_n) * YeTejas(t
//        Real qdot   = std::min(1.0, X_n) * (qdotScheck_H(Ye	//        Real qdot   = std::min(1.0, X_n) * (qdotScheck_H(Ye
     //   Real qdot = std::min(1.0,X_n) * (Heating_QW_Modifie	     //   Real qdot = std::min(1.0,X_n) * (Heating_QW_Modifie
      //  Real qdot = qdotQW(temp, x, Ye_i, time) / erg2MeV;	      //  Real qdot = qdotQW(temp, x, Ye_i, time) / erg2MeV;
        Real qdot   = ExpSupp * std::min(1.0,X_n) * (Heating_	        Real qdot   = ExpSupp * std::min(1.0,X_n) * (Heating_
//        std::cout << "qdot = " << qdot << " erg/s/g" << std	//        std::cout << "qdot = " << qdot << " erg/s/g" << std
//        if(std::isnan(YeSourceHEOS(temp,Ye_i,rho,r)) || std	//        if(std::isnan(YeSourceHEOS(temp,Ye_i,rho,r)) || std
//          if(std::isnan(YeSourceHEOS(temp,Ye_i,rho,r))) {	//          if(std::isnan(YeSourceHEOS(temp,Ye_i,rho,r))) {
//            std::cout << "Source gives NaN" << std::endl;	//            std::cout << "Source gives NaN" << std::endl;
//          }							//          }
//          if(std::isnan(YeSinkHEOS(temp,Ye_i,rho,r))) {	//          if(std::isnan(YeSinkHEOS(temp,Ye_i,rho,r))) {
//            std::cout << "Sink gives NaN" << std::endl;	//            std::cout << "Sink gives NaN" << std::endl;
//          }							//          }
//          std::cout << "r                    = " << r << " 	//          std::cout << "r                    = " << r << " 
//          std::cout << "P(in troubled zone)  = " << p << " 	//          std::cout << "P(in troubled zone)  = " << p << " 
//          std::cout << "rho(in troubled zone)= " << rho << 	//          std::cout << "rho(in troubled zone)= " << rho << 
//	  std::cout << "Ye(in troubled zone) = " << Ye_i << s	//	  std::cout << "Ye(in troubled zone) = " << Ye_i << s
//	  std::cout << "T(in troubled zone)  = " << temp << "	//	  std::cout << "T(in troubled zone)  = " << temp << "
//          std::cout << " "  << std::endl;			//          std::cout << " "  << std::endl;
//        }							//        }

        // Find electron fraction and energy increments		        // Find electron fraction and energy increments
        Real dYe = dt*vdYedr;					        Real dYe = dt*vdYedr;
        Real de  = dt*prim(IDN,k,j,i) * qdot; // erg/cm^-3	        Real de  = dt*prim(IDN,k,j,i) * qdot; // erg/cm^-3

        // Update conserved composition and energy fields	        // Update conserved composition and energy fields
        cons_scalar(ye_index,k,j,i) += dYe*prim(IDN,k,j,i); /	        cons_scalar(ye_index,k,j,i) += dYe*prim(IDN,k,j,i); /
        if (cons(IEN,k,j,i)>1.0e50) {				        if (cons(IEN,k,j,i)>1.0e50) {
          std::cout << "(helm_eos) before e update:" << std::	          std::cout << "(helm_eos) before e update:" << std::
          std::cout << "e = " << cons(IEN,k,j,i) << std::endl	          std::cout << "e = " << cons(IEN,k,j,i) << std::endl
          std::cout << "r = " << r << " cm" << std::endl;	          std::cout << "r = " << r << " cm" << std::endl;
        }							        }
        cons(IEN,k,j,i) += de;                              /	        cons(IEN,k,j,i) += de;                              /
        if(cons(IEN,k,j,i)>1.0e50) {				        if(cons(IEN,k,j,i)>1.0e50) {
          std::cout << "(heat_cool) dt   = " << dt << " s" <<	          std::cout << "(heat_cool) dt   = " << dt << " s" <<
          std::cout << "            r    = " << r    << " cm"	          std::cout << "            r    = " << r    << " cm"
          std::cout << "            E    = " << cons(IEN,k,j,	          std::cout << "            E    = " << cons(IEN,k,j,
          std::cout << "            rho  = " << rho  << " g/c	          std::cout << "            rho  = " << rho  << " g/c
          std::cout << "            P    = " << p    << " erg	          std::cout << "            P    = " << p    << " erg
          std::cout << "         T (MeV) = " << temp    << " 	          std::cout << "         T (MeV) = " << temp    << " 
          std::cout << "           T (K) = " << temp / kbol_M	          std::cout << "           T (K) = " << temp / kbol_M
          std::cout << "            Ye   = " << Ye_i << std::	          std::cout << "            Ye   = " << Ye_i << std::
          std::cout << "           qdot  = " << qdot << " erg	          std::cout << "           qdot  = " << qdot << " erg

        }							        }
        if(std::isnan(cons_scalar(ye_index,k,j,i))) {		        if(std::isnan(cons_scalar(ye_index,k,j,i))) {
          std::cout << "(heat_cool) NANS (2) (cons_scalar)" <	          std::cout << "(heat_cool) NANS (2) (cons_scalar)" <
          std::cout << "Ye_i  = " << Ye_i << std::endl;		          std::cout << "Ye_i  = " << Ye_i << std::endl;
          std::cout << "p     = " << p    << "erg/cm^3" <<std	          std::cout << "p     = " << p    << "erg/cm^3" <<std
          std::cout << "temp  = " << temp << "MeV" <<std::end	          std::cout << "temp  = " << temp << "MeV" <<std::end
          std::cout << "rho   = " << rho  << "g/cm^3" <<std::	          std::cout << "rho   = " << rho  << "g/cm^3" <<std::
          std::cout << " " << std::endl;			          std::cout << " " << std::endl;
        }							        }
      }								      }
    }								    }
  }								  }
  return;							  return;
}								}

// Inflow Boundary Condition					// Inflow Boundary Condition
void InflowInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaAr	void InflowInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaAr
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh) {		                   int je, int ks, int ke, int ngh) {

  Real rho_new;							  Real rho_new;
  AthenaArray<int>& my_data1 = pmb->pmy_mesh->iuser_mesh_data	  AthenaArray<int>& my_data1 = pmb->pmy_mesh->iuser_mesh_data
  AthenaArray<Real>& my_data2 = pmb->pmy_mesh->ruser_mesh_dat	  AthenaArray<Real>& my_data2 = pmb->pmy_mesh->ruser_mesh_dat
  AthenaArray<Real>& my_data3 = pmb->pmy_mesh->ruser_mesh_dat	  AthenaArray<Real>& my_data3 = pmb->pmy_mesh->ruser_mesh_dat

  Real &rho_old{my_data2(0)};					  Real &rho_old{my_data2(0)};
  Real &T_equilibrium{my_data3(0)};				  Real &T_equilibrium{my_data3(0)};
  // Ncycle is updated twice per time cycle because there are	  // Ncycle is updated twice per time cycle because there are
  int &ncycle_x2{my_data1(0)};					  int &ncycle_x2{my_data1(0)};
  if (time == 0.0) {						  if (time == 0.0) {
    ncycle_x2 = 0;						    ncycle_x2 = 0;
  } else {							  } else {
    ncycle_x2 += 1;						    ncycle_x2 += 1;
  }								  }

  // Divide ncycle_x2 by 2 to get the actual cycle number	  // Divide ncycle_x2 by 2 to get the actual cycle number
  Real ncycle = ncycle_x2 / 2.0;				  Real ncycle = ncycle_x2 / 2.0;
  int Roundncycle = round(ncycle);				  int Roundncycle = round(ncycle);

  // Global tau is calcated in UserWorkInLoop			  // Global tau is calcated in UserWorkInLoop
  Real tau = global_tau;					  Real tau = global_tau;
  // Final zone velocity, used to determine if an explosion h	  // Final zone velocity, used to determine if an explosion h
  Real Vr_FZ = Vr_FinalActiveZone;				  Real Vr_FZ = Vr_FinalActiveZone;

  // perturb base density every n'th cycle			  // perturb base density every n'th cycle
  if (Roundncycle == ncycle) {					  if (Roundncycle == ncycle) {
    if (Roundncycle % nthcycle == 0) {				    if (Roundncycle % nthcycle == 0) {
      if (time != 0.0) {					      if (time != 0.0) {
        if ((tau < tau_v * (1.0 + tau_epsilon)) && (tau > tau	        if ((tau < tau_v * (1.0 + tau_epsilon)) && (tau > tau
          rho_new = rho_old;					          rho_new = rho_old;
          std::cout << "converged" << std::endl;		          std::cout << "converged" << std::endl;
          std::cout << "ncycle  = " << ncycle << std::endl;	          std::cout << "ncycle  = " << ncycle << std::endl;
          std::cout << "rho_new = " << rho_new << " g/cm^3" <	          std::cout << "rho_new = " << rho_new << " g/cm^3" <
          std::cout << "active  = " << prim(IDN,ks,js,is) << 	          std::cout << "active  = " << prim(IDN,ks,js,is) << 
          std::cout << "tau     = " << tau << std::endl;	          std::cout << "tau     = " << tau << std::endl;
          std::cout << "time    = " << time << " s" << std::e	          std::cout << "time    = " << time << " s" << std::e
        } else if (tau < tau_v * (1.0 - tau_epsilon)) {		        } else if (tau < tau_v * (1.0 - tau_epsilon)) {
          // if in an explosion regime, dont update rho		          // if in an explosion regime, dont update rho
          if(Vr_FZ <= 0.0) {					          if(Vr_FZ <= 0.0) {
            rho_new = rho_old * (1.0 + rho_epsilon);		            rho_new = rho_old * (1.0 + rho_epsilon);
          } else {						          } else {
            std::cout << "Vr(Last Active Zone) = " << Vr_FZ <	            std::cout << "Vr(Last Active Zone) = " << Vr_FZ <
            rho_new = rho_old;					            rho_new = rho_old;
          }							          }
          std::cout << "too small" << std::endl;		          std::cout << "too small" << std::endl;
          std::cout << "ncycle  = " << ncycle << std::endl;	          std::cout << "ncycle  = " << ncycle << std::endl;
          std::cout << "rho_new = " << rho_new << " g/cm^3" <	          std::cout << "rho_new = " << rho_new << " g/cm^3" <
          std::cout << "active  = " << prim(IDN,ks,js,is) << 	          std::cout << "active  = " << prim(IDN,ks,js,is) << 
          std::cout << "tau     = " << tau << std::endl;	          std::cout << "tau     = " << tau << std::endl;
          std::cout << "time    = " << time << " s" << std::e	          std::cout << "time    = " << time << " s" << std::e
        } else if (tau > tau_v * (1.0 + tau_epsilon)) {		        } else if (tau > tau_v * (1.0 + tau_epsilon)) {
          // if in an explosion regime, dont update rho		          // if in an explosion regime, dont update rho
          if(Vr_FZ <= 0.0) {					          if(Vr_FZ <= 0.0) {
            rho_new = rho_old * (1.0 - rho_epsilon);		            rho_new = rho_old * (1.0 - rho_epsilon);
          } else {						          } else {
            std::cout << "Vr(Last Active Zone) = " << Vr_FZ <	            std::cout << "Vr(Last Active Zone) = " << Vr_FZ <
            rho_new = rho_old;					            rho_new = rho_old;
          }							          }
          std::cout << "too big" << std::endl;			          std::cout << "too big" << std::endl;
          std::cout << "ncycle  = " << ncycle << std::endl;	          std::cout << "ncycle  = " << ncycle << std::endl;
          std::cout << "rho_new = " << rho_new << " g/cm^3" <	          std::cout << "rho_new = " << rho_new << " g/cm^3" <
          std::cout << "active  = " << prim(IDN,ks,js,is) << 	          std::cout << "active  = " << prim(IDN,ks,js,is) << 
          std::cout << "tau     = " << tau << std::endl;	          std::cout << "tau     = " << tau << std::endl;
          std::cout << "time    = " << time << " s" << std::e	          std::cout << "time    = " << time << " s" << std::e
        } else {						        } else {
          std::cout << "(accretion.cpp) Somehow I've subverte	          std::cout << "(accretion.cpp) Somehow I've subverte
        }							        }
      } else {							      } else {
        std::cout << "t = 0, using default rho0" << std::endl	        std::cout << "t = 0, using default rho0" << std::endl
        rho_new = rho_0;					        rho_new = rho_0;
        rho_old = rho_new;					        rho_old = rho_new;
      }								      }
    } else {							    } else {
      if (time == 0.0 || ncycle < 1.0) {			      if (time == 0.0 || ncycle < 1.0) {
        // Use user-specified base density at t=0		        // Use user-specified base density at t=0
        std::cout << "time = 0s or ncycle < 1, using default 	        std::cout << "time = 0s or ncycle < 1, using default 
        rho_new = rho_0;					        rho_new = rho_0;
        rho_old = rho_new;					        rho_old = rho_new;
      } else {							      } else {
        // Use ghost zone value from previous cycle (this ass	        // Use ghost zone value from previous cycle (this ass
        rho_new = rho_old;					        rho_new = rho_old;
      }								      }
    }								    }
  } else {							  } else {
    if (time == 0.0 || ncycle < 1.0) {				    if (time == 0.0 || ncycle < 1.0) {
      // Use user-specified base density at t=0			      // Use user-specified base density at t=0
      std::cout << "time = 0s or ncycle < 1, using default rh	      std::cout << "time = 0s or ncycle < 1, using default rh
      rho_new = rho_0;						      rho_new = rho_0;
      rho_old = rho_new;					      rho_old = rho_new;
    } else {							    } else {
        rho_new = rho_old;					        rho_new = rho_old;
    }								    }
  }								  }

  // Just sending in input values here because I don't feel l	  // Just sending in input values here because I don't feel l
  Real* Yeq_ptr  = &ye_0;					  Real* Yeq_ptr  = &ye_0;
//  Real Arr[1];						//  Real Arr[1];
//  Single_NR(Arr,r_0);						//  Single_NR(Arr,r_0);
//  Real Teq = Arr[0];						//  Real Teq = Arr[0];
//  Real T_g       = T_0;					//  Real T_g       = T_0;

  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
          prim(IDN,k,j,is-i)                  = rho_new;	          prim(IDN,k,j,is-i)                  = rho_new;
          rho_old                             = prim(IDN,k,j,	          rho_old                             = prim(IDN,k,j,
          prim(IVX,k,j,is-i)                  = prim(IVX,k,j,	          prim(IVX,k,j,is-i)                  = prim(IVX,k,j,
          prim(IVY,k,j,is-i)                  = 0.0;		          prim(IVY,k,j,is-i)                  = 0.0;
          prim(IVZ,k,j,is-i)                  = 0.0;		          prim(IVZ,k,j,is-i)                  = 0.0;
          Real ye_a                           = pmb->pscalars	          Real ye_a                           = pmb->pscalars
          Real rho_a                          = prim(IDN,k,j,	          Real rho_a                          = prim(IDN,k,j,
          Real r_a                            = pco->x1v(is);	          Real r_a                            = pco->x1v(is);
          pmb->pscalars->r(ye_index,k,j,is-i) = ye_a;		          pmb->pscalars->r(ye_index,k,j,is-i) = ye_a;
          Real* ye_g                          = &pmb->pscalar	          Real* ye_g                          = &pmb->pscalar

          // Single NR step to find equilibrium temperature	          // Single NR step to find equilibrium temperature
          Real Arr[1];						          Real Arr[1];
          Single_NR(Arr, r_a, rho_a, ye_a);			          Single_NR(Arr, r_a, rho_a, ye_a);
          Real Teq      = Arr[0];				          Real Teq      = Arr[0];
          T_equilibrium = Teq;					          T_equilibrium = Teq;
          pmb->pscalars->r(t_index,k,j,is-i) = Teq;		          pmb->pscalars->r(t_index,k,j,is-i) = Teq;
//          pmb->pscalars->r(t_index,k,j,is-i) = pmb->pscalar	//          pmb->pscalars->r(t_index,k,j,is-i) = pmb->pscalar

          Real r_scalar[nscalar_size];				          Real r_scalar[nscalar_size];
          Real s_scalar[nscalar_size];				          Real s_scalar[nscalar_size];
          for (int ns=0; ns<nscalar_size; ns++) {		          for (int ns=0; ns<nscalar_size; ns++) {
            r_scalar[ns] = pmb->pscalars->r(ns,k,j,is-i);	            r_scalar[ns] = pmb->pscalars->r(ns,k,j,is-i);
            s_scalar[ns] = pmb->pscalars->s(ns,k,j,is-i);	            s_scalar[ns] = pmb->pscalars->s(ns,k,j,is-i);
          }							          }

          if (NON_BAROTROPIC_EOS) {				          if (NON_BAROTROPIC_EOS) {
            prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(rho_	            prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(rho_
//            prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(rh	//            prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(rh
          }							          }
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);			          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);			          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);			          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

// Inflow Boundary Condition					// Inflow Boundary Condition
void InflowMdotInnerX1(MeshBlock *pmb, Coordinates *pco, Athe	void InflowMdotInnerX1(MeshBlock *pmb, Coordinates *pco, Athe
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh) {		                   int je, int ks, int ke, int ngh) {
  Real r0 = pco->x1v(is);					  Real r0 = pco->x1v(is);
  Real Arr[2];							  Real Arr[2];
  Double_NR(Arr,r0,rho_0);					  Double_NR(Arr,r0,rho_0);

  T_eq           = Arr[0];					  T_eq           = Arr[0];
  Ye_eq          = Arr[1];					  Ye_eq          = Arr[1];
  Real* Yeq_ptr  = &Ye_eq;					  Real* Yeq_ptr  = &Ye_eq;
  Real p_0       = pmb->peos->PresFromRhoT(rho_0, T_eq, Yeq_p	  Real p_0       = pmb->peos->PresFromRhoT(rho_0, T_eq, Yeq_p

  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    // Real phi = pco->x3v(k);					    // Real phi = pco->x3v(k);
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        prim(IDN,k,j,is-i) = rho_0;				        prim(IDN,k,j,is-i) = rho_0;
        Real v = prim(IVX,k,j,is) * SQR(pco->x1v(is) / pco->x	        Real v = prim(IVX,k,j,is) * SQR(pco->x1v(is) / pco->x
        prim(IVX,k,j,is-i) = std::max(v, 0.0);			        prim(IVX,k,j,is-i) = std::max(v, 0.0);
        prim(IVY,k,j,is-i) = 0.0;				        prim(IVY,k,j,is-i) = 0.0;
        prim(IVZ,k,j,is-i) = 0.0;				        prim(IVZ,k,j,is-i) = 0.0;
        if (NON_BAROTROPIC_EOS)					        if (NON_BAROTROPIC_EOS)
          prim(IPR,k,j,is-i) = p_0;				          prim(IPR,k,j,is-i) = p_0;
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);			          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);			          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);			          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

void HSEInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArray	void HSEInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArray
                FaceField &b, Real time, Real dt, int is, int	                FaceField &b, Real time, Real dt, int is, int
                int je, int ks, int ke, int ngh) {		                int je, int ks, int ke, int ngh) {

  Real r0 = pco->x1v(is);					  Real r0 = pco->x1v(is);
  Real Arr[2];							  Real Arr[2];
  Double_NR(Arr,r0,rho_0);					  Double_NR(Arr,r0,rho_0);

  T_eq           = Arr[0];					  T_eq           = Arr[0];
  Ye_eq          = Arr[1];					  Ye_eq          = Arr[1];
  Real* Yeq_ptr  = &Ye_eq;					  Real* Yeq_ptr  = &Ye_eq;
  Real p_0       = pmb->peos->PresFromRhoT(rho_0, T_eq, Yeq_p	  Real p_0       = pmb->peos->PresFromRhoT(rho_0, T_eq, Yeq_p
  dpdd_0         = pmb->peos->AsqFromRhoP(rho_0, p_0, Yeq_ptr	  dpdd_0         = pmb->peos->AsqFromRhoP(rho_0, p_0, Yeq_ptr

  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    // Real phi = pco->x3v(k);					    // Real phi = pco->x3v(k);
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        Real r = pco->x1v(is-i);				        Real r = pco->x1v(is-i);
        prim(IDN,k,j,is-i) = rho_0 * std::exp((r0 - r) * mu /	        prim(IDN,k,j,is-i) = rho_0 * std::exp((r0 - r) * mu /
        Real v = prim(IVX,k,j,is) * prim(IDN,k,j,is) / prim(I	        Real v = prim(IVX,k,j,is) * prim(IDN,k,j,is) / prim(I
        prim(IVX,k,j,is-i) = std::max(v, 0.0);			        prim(IVX,k,j,is-i) = std::max(v, 0.0);
        prim(IVY,k,j,is-i) = 0.0;				        prim(IVY,k,j,is-i) = 0.0;
        prim(IVZ,k,j,is-i) = 0.0;				        prim(IVZ,k,j,is-i) = 0.0;
        if (NON_BAROTROPIC_EOS) {				        if (NON_BAROTROPIC_EOS) {
          prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(prim(I	          prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(prim(I
        }							        }
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);			          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);			          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);			          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

void HSE2InnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArra	void HSE2InnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArra
                 FaceField &b, Real time, Real dt, int is, in	                 FaceField &b, Real time, Real dt, int is, in
                int je, int ks, int ke, int ngh) {		                int je, int ks, int ke, int ngh) {
  AthenaArray<Real> out1;					  AthenaArray<Real> out1;
  out1.NewAthenaArray(7);					  out1.NewAthenaArray(7);
  Real r0 = pco->x1v(is);					  Real r0 = pco->x1v(is);
  Real Arr[2];							  Real Arr[2];
  Double_NR(Arr,r0,rho_0);					  Double_NR(Arr,r0,rho_0);

  T_eq           = Arr[0];					  T_eq           = Arr[0];
  Ye_eq          = Arr[1];					  Ye_eq          = Arr[1];
  Real* Yeq_ptr  = &Ye_eq;					  Real* Yeq_ptr  = &Ye_eq;
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    // Real phi = pco->x3v(k);					    // Real phi = pco->x3v(k);
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        Real r = pco->x1v(is-i);				        Real r = pco->x1v(is-i);
        prim(IDN,k,j,is-i) = rho_0 * std::exp((r0 - r) * mu /	        prim(IDN,k,j,is-i) = rho_0 * std::exp((r0 - r) * mu /
        prim(IVX,k,j,is-i) = std::max(prim(IVX,k,j,is), 0.0);	        prim(IVX,k,j,is-i) = std::max(prim(IVX,k,j,is), 0.0);
        prim(IVY,k,j,is-i) = 0.0;				        prim(IVY,k,j,is-i) = 0.0;
        prim(IVZ,k,j,is-i) = 0.0;				        prim(IVZ,k,j,is-i) = 0.0;
        if (NON_BAROTROPIC_EOS) {				        if (NON_BAROTROPIC_EOS) {
          prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(prim(I	          prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(prim(I
        }							        }
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);			          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);			          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);			          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

// Outflow Boundary Condition					// Outflow Boundary Condition
void OutflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaA	void OutflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaA
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh) {		                   int je, int ks, int ke, int ngh) {
  Real re = pco->x1v(ie);					  Real re = pco->x1v(ie);
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        Real rgh = pco->x1v(ie+i);				        Real rgh = pco->x1v(ie+i);
        Real ratio = re / rgh;					        Real ratio = re / rgh;
        prim(IDN,k,j,ie+i) = prim(IDN,k,j,ie) * SQR(ratio);	        prim(IDN,k,j,ie+i) = prim(IDN,k,j,ie) * SQR(ratio);
        prim(IVX,k,j,ie+i) = std::max(prim(IVX,k,j,ie), 0.0);	        prim(IVX,k,j,ie+i) = std::max(prim(IVX,k,j,ie), 0.0);
        prim(IVY,k,j,ie+i) = prim(IVY,k,j,ie) * ratio;		        prim(IVY,k,j,ie+i) = prim(IVY,k,j,ie) * ratio;
        prim(IVZ,k,j,ie+i) = prim(IVZ,k,j,ie) * ratio;		        prim(IVZ,k,j,ie+i) = prim(IVZ,k,j,ie) * ratio;
        if (NON_BAROTROPIC_EOS)					        if (NON_BAROTROPIC_EOS)
          prim(IPR,k,j,ie+i) = prim(IPR,k,j,ie); // Constant 	          prim(IPR,k,j,ie+i) = prim(IPR,k,j,ie); // Constant 
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(ie+i+1)) = b.x1f(k,j,(ie+1));		          b.x1f(k,j,(ie+i+1)) = b.x1f(k,j,(ie+1));
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(ie+i)) = b.x2f(k,j,ie);			          b.x2f(k,j,(ie+i)) = b.x2f(k,j,ie);
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(ie+i)) = b.x3f(k,j,ie);			          b.x3f(k,j,(ie+i)) = b.x3f(k,j,ie);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

// Inflow Boundary Condition at outer boundary			// Inflow Boundary Condition at outer boundary
void InflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaAr	void InflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaAr
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh) {		                   int je, int ks, int ke, int ngh) {
  AthenaArray<Real>& DATA = pmb->pmy_mesh->ruser_mesh_data[8]	  AthenaArray<Real>& DATA = pmb->pmy_mesh->ruser_mesh_data[8]
  Real &P_Ghost{DATA(0)};					  Real &P_Ghost{DATA(0)};
							      |	  Real c = 2.99792458e10;              // Speed of light in c
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        if (prim(IVX,k,j,ie) < 0.0) {				        if (prim(IVX,k,j,ie) < 0.0) {
          prim(IDN,k,j,ie+i) = rho_f;				          prim(IDN,k,j,ie+i) = rho_f;
          prim(IVX,k,j,ie+i) = v_f;				          prim(IVX,k,j,ie+i) = v_f;
          prim(IVY,k,j,ie+i) = 0.0;				          prim(IVY,k,j,ie+i) = 0.0;
          prim(IVZ,k,j,ie+i) = 0.0;				          prim(IVZ,k,j,ie+i) = 0.0;
        } else {						        } else {
          prim(IDN,k,j,ie+i) = rho_f; //prim(IDN,k,j,ie);	          prim(IDN,k,j,ie+i) = rho_f; //prim(IDN,k,j,ie);
          prim(IVX,k,j,ie+i) = v_f;  //prim(IVX,k,j,ie);	          prim(IVX,k,j,ie+i) = v_f;  //prim(IVX,k,j,ie);
          prim(IVY,k,j,ie+i) = 0.0;				          prim(IVY,k,j,ie+i) = 0.0;
          prim(IVZ,k,j,ie+i) = 0.0;				          prim(IVZ,k,j,ie+i) = 0.0;

        }							        }
        pmb->pscalars->r(ye_index,k,j,ie+i) = ye_f;		        pmb->pscalars->r(ye_index,k,j,ie+i) = ye_f;
        // initialize temperature to floating			        // initialize temperature to floating
        pmb->pscalars->r(t_index,k,j,ie+i)  = pmb->pscalars->	        pmb->pscalars->r(t_index,k,j,ie+i)  = pmb->pscalars->
//	Real* ye_ptr = pmb->pscalars->r(ye_index,k,j,ie+i);	//	Real* ye_ptr = pmb->pscalars->r(ye_index,k,j,ie+i);
        Real r_scalar[nscalar_size];				        Real r_scalar[nscalar_size];
        Real s_scalar[nscalar_size];				        Real s_scalar[nscalar_size];
        for (int ns=0; ns<nscalar_size; ns++) {			        for (int ns=0; ns<nscalar_size; ns++) {
          r_scalar[ns] = pmb->pscalars->r(ns,k,j,ie+i);		          r_scalar[ns] = pmb->pscalars->r(ns,k,j,ie+i);
          s_scalar[ns] = pmb->pscalars->s(ns,k,j,ie+i);		          s_scalar[ns] = pmb->pscalars->s(ns,k,j,ie+i);
        }							        }

        if (NON_BAROTROPIC_EOS) {				        if (NON_BAROTROPIC_EOS) {
     //     std::cout << "(PGEN) InflowOuterX1:" << std::endl	     //     std::cout << "(PGEN) InflowOuterX1:" << std::endl
     //     std::cout << "p_f (input for GZ) = " << p_f << " 	     //     std::cout << "p_f (input for GZ) = " << p_f << " 
     //     std::cout << "pModify            = " << pModify <	     //     std::cout << "pModify            = " << pModify <
     //     std::cout << "p_f (active zone)  = " << prim(IPR,	     //     std::cout << "p_f (active zone)  = " << prim(IPR,
          Real P_IC = p_f;					          Real P_IC = p_f;
//          pmb->pscalars->r(t_index,k,j,ie+i) = pmb->peos->T	//          pmb->pscalars->r(t_index,k,j,ie+i) = pmb->peos->T
          // Repopulate the T scalar array with newly acquire	          // Repopulate the T scalar array with newly acquire
 //         for (int ns=0; ns<nscalar_size; ns++) {		 //         for (int ns=0; ns<nscalar_size; ns++) {
 //           r_scalar[ns] = pmb->pscalars->r(ns,k,j,ie+i);	 //           r_scalar[ns] = pmb->pscalars->r(ns,k,j,ie+i);
 //           s_scalar[ns] = pmb->pscalars->s(ns,k,j,ie+i);	 //           s_scalar[ns] = pmb->pscalars->s(ns,k,j,ie+i);
 //         }							 //         }
          Real gamma         = pmb->peos->GammaFromRhoT(prim(	          Real gamma         = pmb->peos->GammaFromRhoT(prim(
          prim(IPR,k,j,ie+i) = rho_f * std::pow(v_f,2.0) / (g |	          std::cout << "1" << std::endl;
							      >	  //        Real etot          = pmb->peos->EtotFromRhoT(prim
							      >	          std::cout << "2" << std::endl;
							      >	          Real etot = std::pow(c,2.0);
							      >	          prim(IPR,k,j,ie+i) = rho_f * (etot + std::pow(c,2.0
          P_GZ               = prim(IPR,ke,je,ie+1);		          P_GZ               = prim(IPR,ke,je,ie+1);
          P_Ghost            = P_GZ;				          P_Ghost            = P_GZ;
  //        pmb->pscalars->r(t_index,k,j,ie+i)=pmb->peos->TFr	  //        pmb->pscalars->r(t_index,k,j,ie+i)=pmb->peos->TFr
        }							        }
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(ie+i+1)) = b.x1f(k,j,(ie+1));		          b.x1f(k,j,(ie+i+1)) = b.x1f(k,j,(ie+1));
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(ie+i)) = b.x2f(k,j,ie);			          b.x2f(k,j,(ie+i)) = b.x2f(k,j,ie);
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(ie+i)) = b.x3f(k,j,ie);			          b.x3f(k,j,(ie+i)) = b.x3f(k,j,ie);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

void MeshBlock::UserWorkInLoop() {				void MeshBlock::UserWorkInLoop() {
  AthenaArray<Real>& my_data = pmy_mesh->ruser_mesh_data[5];	  AthenaArray<Real>& my_data = pmy_mesh->ruser_mesh_data[5];
  Real &local_sum{my_data(0)};					  Real &local_sum{my_data(0)};
  Real t = pmy_mesh->time;					  Real t = pmy_mesh->time;
  Real sigma_nue_n = sigma_0 * ((1.0 + 3.0 * std::pow(g_a,2))	  Real sigma_nue_n = sigma_0 * ((1.0 + 3.0 * std::pow(g_a,2))
  Real testrho = phydro->w(IDN,ks,js,is);			  Real testrho = phydro->w(IDN,ks,js,is);
  if (lid == 0) {						  if (lid == 0) {
    local_sum = 0.0;						    local_sum = 0.0;
  }								  }
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      for (int i=is; i<=ie-1; ++i) {				      for (int i=is; i<=ie-1; ++i) {
        Real rho_ip1 = phydro->w(IDN,k,j,i+1);			        Real rho_ip1 = phydro->w(IDN,k,j,i+1);
        Real rho_i   = phydro->w(IDN,k,j,i);			        Real rho_i   = phydro->w(IDN,k,j,i);
        Real r_ip1   = pcoord->x1v(i+1);			        Real r_ip1   = pcoord->x1v(i+1);
        Real r_i     = pcoord->x1v(i);				        Real r_i     = pcoord->x1v(i);
        Real ye_ip1  = pscalars->r(ye_index,k,j,i+1);		        Real ye_ip1  = pscalars->r(ye_index,k,j,i+1);
        Real ye_i    = pscalars->r(ye_index,k,j,i);		        Real ye_i    = pscalars->r(ye_index,k,j,i);
        Real Chi_ip1 = (1.0 - ye_ip1);				        Real Chi_ip1 = (1.0 - ye_ip1);
        Real Chi_i   = (1.0 - ye_i);				        Real Chi_i   = (1.0 - ye_i);
        Real deltaR  = r_ip1 - r_i;				        Real deltaR  = r_ip1 - r_i;
        local_sum    += 0.5 * deltaR * sigma_nue_n * Na * ((C	        local_sum    += 0.5 * deltaR * sigma_nue_n * Na * ((C
      }								      }
    }								    }
  }								  }
  if (lid == pmy_mesh->nblocal-1) {				  if (lid == pmy_mesh->nblocal-1) {
    Real global_integral;					    Real global_integral;
    MPI_Allreduce(&local_sum, &global_integral, 1,		    MPI_Allreduce(&local_sum, &global_integral, 1,
                  MPI_ATHENA_REAL, MPI_SUM, MPI_COMM_WORLD);	                  MPI_ATHENA_REAL, MPI_SUM, MPI_COMM_WORLD);
    global_tau = global_integral;				    global_tau = global_integral;
    Vr_FinalActiveZone = phydro->w(IVX,ke,je,ie);		    Vr_FinalActiveZone = phydro->w(IVX,ke,je,ie);
  }								  }
}								}

void MeshBlock::UserWorkBeforeOutput(ParameterInput *pin) {	void MeshBlock::UserWorkBeforeOutput(ParameterInput *pin) {
  for(int k=ks; k<=ke; k++) {					  for(int k=ks; k<=ke; k++) {
    for(int j=js; j<=je; j++) {					    for(int j=js; j<=je; j++) {
      for(int i=is; i<=ie; i++) {				      for(int i=is; i<=ie; i++) {
        efrac         = &pscalars->r(ye_index,k,j,i);		        efrac         = &pscalars->r(ye_index,k,j,i);
     //   Real temp     = peos->TFromRhoP(phydro->w(IDN,k,j,i	     //   Real temp     = peos->TFromRhoP(phydro->w(IDN,k,j,i
        Real temp     = pscalars->r(t_index,k,j,i);		        Real temp     = pscalars->r(t_index,k,j,i);
        Real r        = pcoord->x1v(i);				        Real r        = pcoord->x1v(i);
        Real x        = std::pow((1.0-(r_0*r_0)/(r*r)),0.5);	        Real x        = std::pow((1.0-(r_0*r_0)/(r*r)),0.5);
        Real kbol_MeV = 8.61733326*std::pow(10,-11);         	        Real kbol_MeV = 8.61733326*std::pow(10,-11);         
        Real ye       = pscalars->r(ye_index,k,j,i);		        Real ye       = pscalars->r(ye_index,k,j,i);
        Real rho      = phydro->w(IDN,k,j,i);			        Real rho      = phydro->w(IDN,k,j,i);
        Real erg2MeV  = 6.24151e5;				        Real erg2MeV  = 6.24151e5;

        // Read in T_equilibrium				        // Read in T_equilibrium
        AthenaArray<Real>& my_data = pmy_mesh->ruser_mesh_dat	        AthenaArray<Real>& my_data = pmy_mesh->ruser_mesh_dat
        AthenaArray<Real>& DATA    = pmy_mesh->ruser_mesh_dat	        AthenaArray<Real>& DATA    = pmy_mesh->ruser_mesh_dat
        Real &Tequil{my_data(0)};				        Real &Tequil{my_data(0)};
        Real &P_GhostZ{DATA(0)};				        Real &P_GhostZ{DATA(0)};
//        std::cout << "P_GhostZ (Output step) = " << P_Ghost	//        std::cout << "P_GhostZ (Output step) = " << P_Ghost

        Real temp_MeV = temp * kbol_MeV;			        Real temp_MeV = temp * kbol_MeV;
        Real t = pmy_mesh->time;				        Real t = pmy_mesh->time;
        Real X_n    = 1.0; //Xn(rho, temp);			        Real X_n    = 1.0; //Xn(rho, temp);
        if (r>5.0e6) {						        if (r>5.0e6) {
//        if (temp < 1.0) {					//        if (temp < 1.0) {
          X_n = X_nucleon(rho, temp);				          X_n = X_nucleon(rho, temp);
        }							        }
        Real ExpSupp = std::exp(-1.0 * rho / rho_0);		        Real ExpSupp = std::exp(-1.0 * rho / rho_0);

        // Define user output variables:			        // Define user output variables:
        // Temperature						        // Temperature
        user_out_var(0,k,j,i) = temp;				        user_out_var(0,k,j,i) = temp;
        // Qdot = H - C						        // Qdot = H - C
//        user_out_var(1,k,j,i) = qdotScheck_H(pscalars->r(ye	//        user_out_var(1,k,j,i) = qdotScheck_H(pscalars->r(ye
//                                - qdotScheck_C(temp,pscalar	//                                - qdotScheck_C(temp,pscalar
//        user_out_var(1,k,j,i) = qdotQW(temp_MeV, x, ye, t) 	//        user_out_var(1,k,j,i) = qdotQW(temp_MeV, x, ye, t) 
        user_out_var(1,k,j,i) = ExpSupp * std::min(1.0, X_n) 	        user_out_var(1,k,j,i) = ExpSupp * std::min(1.0, X_n) 
        // Sound Speed						        // Sound Speed
//        std::cout << "(Pgen, Userworkbeforeoutput) Before A	//        std::cout << "(Pgen, Userworkbeforeoutput) Before A
//        std::cout << "temp     = " << temp << " K" << std::	//        std::cout << "temp     = " << temp << " K" << std::
//        std::cout << "pressure = " << phydro->w(IPR,k,j,i) 	//        std::cout << "pressure = " << phydro->w(IPR,k,j,i) 
//        std::cout << "ye       = " << pscalars->r(ye_index,	//        std::cout << "ye       = " << pscalars->r(ye_index,
//        std::cout << "rho (w)  = " << phydro->w(IDN,k,j,i) 	//        std::cout << "rho (w)  = " << phydro->w(IDN,k,j,i) 
//        std::cout << "rho (u)  = " << phydro->u(IDN,k,j,i) 	//        std::cout << "rho (u)  = " << phydro->u(IDN,k,j,i) 

        user_out_var(2,k,j,i) = std::sqrt(peos->AsqFromRhoP(p	        user_out_var(2,k,j,i) = std::sqrt(peos->AsqFromRhoP(p
                                                            p	                                                            p
        // Tau value						        // Tau value
        user_out_var(6,k,j,i) = global_tau;			        user_out_var(6,k,j,i) = global_tau;
        // Ghost zone values					        // Ghost zone values
        user_out_var(7,k,j,i)  = phydro->w(IDN,k,j,0);		        user_out_var(7,k,j,i)  = phydro->w(IDN,k,j,0);
        user_out_var(8,k,j,i)  = P_GhostZ; // outer ghost zon	        user_out_var(8,k,j,i)  = P_GhostZ; // outer ghost zon
        user_out_var(9,k,j,i)  = phydro->w(IVX,k,j,0);		        user_out_var(9,k,j,i)  = phydro->w(IVX,k,j,0);
        user_out_var(10,k,j,i) = pscalars->r(ye_index,k,j,0);	        user_out_var(10,k,j,i) = pscalars->r(ye_index,k,j,0);
        user_out_var(11,k,j,i) = Tequil;			        user_out_var(11,k,j,i) = Tequil;
      }								      }
    }								    }
  }								  }
}								}
